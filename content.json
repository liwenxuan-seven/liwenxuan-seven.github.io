{"meta":{"title":"桃木的博客","subtitle":"永远好奇","description":"为记录而建的blog","author":"桃木","url":"http://example.com","root":"/"},"pages":[{"title":"分類","date":"2023-01-31T12:38:07.000Z","updated":"2023-01-31T12:38:31.218Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2023-01-28T14:32:57.356Z","updated":"2023-01-28T14:32:57.356Z","comments":true,"path":"css/custom.css","permalink":"http://example.com/css/custom.css","excerpt":"","text":"/* @font-face { font-family: Candyhome; src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/Candyhome.ttf); font-display: swap; font-weight: lighter; } */ @font-face { font-family: ZhuZiAYuanJWD; src: url(https://npm.elemecdn.com/anzhiyu-blog@1.1.6/fonts/ZhuZiAWan.woff2); font-display: swap; /*font-weight: lighter;*/ } div#menus { font-family: \"ZhuZiAYuanJWD\"; } h1#site-title { font-family: ZhuZiAYuanJWD; font-size: 3em !important; } a.article-title, a.blog-slider__title, a.categoryBar-list-link, h1.post-title { font-family: ZhuZiAYuanJWD; } .iconfont { font-family: \"iconfont\" !important; font-size: 3em; /* 可以定义图标大小 */ font-style: normal; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } /* 时间轴生肖icon */ svg.icon { /* 这里定义svg.icon，避免和Butterfly自带的note标签冲突 */ width: 1em; height: 1em; /* width和height定义图标的默认宽度和高度*/ vertical-align: -0.15em; fill: currentColor; overflow: hidden; } .icon-zhongbiao::before { color: #f7c768; } /* bilibli番剧插件 */ /*#article-container .bangumi-tab.bangumi-active { !*background: var(--anzhiyu-theme);*! !*color: var(--anzhiyu-ahoverbg);*! border-radius: 10px; }*/ a.bangumi-tab:hover { text-decoration: none !important; } /*.bangumi-button:hover { !*background: var(--anzhiyu-theme) !important;*! border-radius: 10px !important; !*color: var(--anzhiyu-ahoverbg) !important;*! }*/ a.bangumi-button.bangumi-nextpage:hover { text-decoration: none !important; } .bangumi-button { padding: 5px 10px !important; } a.bangumi-tab { padding: 5px 10px !important; } svg.icon.faa-tada { font-size: 1.1em; } .bangumi-info-item { border-right: 1px solid #f2b94b; } .bangumi-info-item span { color: #f2b94b; } .bangumi-info-item em { color: #f2b94b; } /* 解决artitalk的图标问题 */ #uploadSource > svg { width: 1.19em; height: 1.5em; } /*top-img黑色透明玻璃效果移除，不建议加，除非你执着于完全一图流或者背景图对比色明显 */ /*#page-header:not(.not-top-img):before { background-color: transparent !important; }*/ /* 首页文章卡片 */ #recent-posts > .recent-post-item { background: rgba(255,255,255,0.9); } /* 首页侧栏卡片 */ #aside-content .card-widget { background: rgba(255,255,255,0.9); } /* 文章页面正文背景 */ div#post { background: rgba(255,255,255,0.9); } /* 分页页面 */ div#page { background: rgba(255,255,255,0.9); } /* 归档页面 */ div#archive { background: rgba(255, 255, 255, 0.9); } /* 标签页面 */ div#tag { background: rgba(255,255,255,0.9); } /* 分类页面 */ div#category { background: rgba(255, 255, 255, 0.9); } /*夜间模式伪类遮罩层透明*/ [data-theme=\"dark\"] #recent-posts > .recent-post-item { background: #121212; } [data-theme=\"dark\"] .card-widget { background: #121212 !important; } [data-theme=\"dark\"] div#post { background: #121212 !important; } [data-theme=\"dark\"] div#tag { background: #121212 !important; } [data-theme=\"dark\"] div#archive { background: #121212 !important; } [data-theme=\"dark\"] div#page { background: #121212 !important; } [data-theme=\"dark\"] div#category { background: #121212 !important; } [data-theme=\"dark\"] div#category { background: transparent !important; } /* 页脚透明 */ #footer { background: transparent !important; } /* 头图透明 */ #page-header { background: transparent !important; } #rightside > div > button { border-radius: 5px; } /* 滚动条 */ ::-webkit-scrollbar { width: 10px; height: 10px; } ::-webkit-scrollbar-thumb { background-color: #3b70fc; border-radius: 2em; } ::-webkit-scrollbar-corner { background-color: transparent; } ::-moz-selection { color: #fff; background-color: #3b70fc; } /* 音乐播放器 */ /* .aplayer .aplayer-lrc { display: none !important; } */ /*.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body { left: -66px !important; transition: all 0.3s; !* 默认情况下缩进左侧66px，只留一点箭头部分 *! }*/ /*.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover { left: 0 !important; transition: all 0.3s; !* 鼠标悬停是左侧缩进归零，完全显示按钮 *! } .aplayer.aplayer-fixed { z-index: 999999 !important; }*/ /* 评论框 */ .vwrap { box-shadow: 2px 2px 5px #bbb; background: rgba(255, 255, 255, 0.3); border-radius: 8px; padding: 30px; margin: 30px 0px 30px 0px; } /* 设置评论框 */ .vcard { box-shadow: 2px 2px 5px #bbb; background: rgba(255, 255, 255, 0.3); border-radius: 8px; padding: 30px; margin: 30px 0px 0px 0px; } /* 鼠标图标 */ body { /*cursor: url(\"/img/x1.cur\"), auto;*/ } a, [type=\"button\"]:not(:disabled), [type=\"reset\"]:not(:disabled), [type=\"submit\"]:not(:disabled), button:not(:disabled) { /*cursor: url(\"/img/x2.cur\"), auto !important;*/ } /* md网站下划线 */ #article-container a:hover { text-decoration: none !important; } #article-container #hpp_talk p img { display: inline; } /* 404页面 */ #error-wrap { position: absolute; top: 40%; right: 0; left: 0; margin: 0 auto; padding: 0 1rem; max-width: 1000px; transform: translate(0, -50%); } #error-wrap .error-content { display: flex; flex-direction: row; justify-content: center; align-items: center; margin: 0 1rem; height: 18rem; border-radius: 8px; background: var(--card-bg); box-shadow: var(--card-box-shadow); transition: all 0.3s; } #error-wrap .error-content .error-img { box-flex: 1; flex: 1; height: 100%; border-top-left-radius: 8px; border-bottom-left-radius: 8px; background-color: #3b70fc; background-position: center; background-size: cover; } #error-wrap .error-content .error-info { box-flex: 1; flex: 1; padding: 0.5rem; text-align: center; font-size: 14px; font-family: Titillium Web, \"PingFang SC\", \"Hiragino Sans GB\", \"Microsoft JhengHei\", \"Microsoft YaHei\", sans-serif; } #error-wrap .error-content .error-info .error_title { margin-top: -4rem; font-size: 9em; } #error-wrap .error-content .error-info .error_subtitle { margin-top: -3.5rem; word-break: break-word; font-size: 1.6em; } #error-wrap .error-content .error-info a { display: inline-block; margin-top: 0.5rem; padding: 0.3rem 1.5rem; background: var(--btn-bg); color: var(--btn-color); } #body-wrap.error .aside-list { display: flex; flex-direction: row; flex-wrap: nowrap; bottom: 0px; position: absolute; padding: 1rem; width: 100%; overflow: scroll; } #body-wrap.error .aside-list .aside-list-group { display: flex; flex-direction: row; flex-wrap: nowrap; max-width: 1200px; margin: 0 auto; } #body-wrap.error .aside-list .aside-list-item { padding: 0.5rem; } #body-wrap.error .aside-list .aside-list-item img { width: 100%; object-fit: cover; border-radius: 12px; } /*#body-wrap.error .aside-list .aside-list-item .thumbnail {*/ /* overflow: hidden;*/ /* width: 230px;*/ /* height: 143px;*/ /* !*background: var(--anzhiyu-card-bg);*!*/ /* display: flex;*/ /*}*/ #body-wrap.error .aside-list .aside-list-item .content .title { -webkit-line-clamp: 2; overflow: hidden; display: -webkit-box; -webkit-box-orient: vertical; line-height: 1.5; justify-content: center; align-items: flex-end; align-content: center; padding-top: 0.5rem; color: white; } #body-wrap.error .aside-list .aside-list-item .content time { display: none; } /* 代码框主题 */ #article-container figure.highlight { border-radius: 10px; }"},{"title":"标签","date":"2023-01-31T12:37:09.000Z","updated":"2023-01-31T12:37:51.180Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"友情鏈接","date":"2023-01-31T12:38:45.000Z","updated":"2023-01-31T12:39:01.635Z","comments":true,"path":"link/index.html","permalink":"http://example.com/link/index.html","excerpt":"","text":""},{"title":"","date":"2023-01-29T03:19:37.094Z","updated":"2023-01-29T03:19:37.094Z","comments":true,"path":"js/ali_font.js","permalink":"http://example.com/js/ali_font.js","excerpt":"","text":"!(function (c) { var l, h, a, t, i, v = '', o = (o = document.getElementsByTagName(\"script\"))[o.length - 1].getAttribute(\"data-injectcss\"), p = function (c, l) { l.parentNode.insertBefore(c, l); }; if (o && !c.__iconfont__svg__cssinject__) { c.__iconfont__svg__cssinject__ = !0; try { document.write( \".svgfont {display: inline-block;width: 1em;height: 1em;fill: currentColor;vertical-align: -0.1em;font-size:16px;}\" ); } catch (c) { console && console.log(c); } } function d() { i || ((i = !0), a()); } function m() { try { t.documentElement.doScroll(\"left\"); } catch (c) { return void setTimeout(m, 50); } d(); } (l = function () { var c, l = document.createElement(\"div\"); (l.innerHTML = v), (v = null), (l = l.getElementsByTagName(\"svg\")[0]) && (l.setAttribute(\"aria-hidden\", \"true\"), (l.style.position = \"absolute\"), (l.style.width = 0), (l.style.height = 0), (l.style.overflow = \"hidden\"), (l = l), (c = document.body).firstChild ? p(l, c.firstChild) : c.appendChild(l)); }), document.addEventListener ? ~[\"complete\", \"loaded\", \"interactive\"].indexOf(document.readyState) ? setTimeout(l, 0) : ((h = function () { document.removeEventListener(\"DOMContentLoaded\", h, !1), l(); }), document.addEventListener(\"DOMContentLoaded\", h, !1)) : document.attachEvent && ((a = l), (t = c.document), (i = !1), m(), (t.onreadystatechange = function () { \"complete\" == t.readyState && ((t.onreadystatechange = null), d()); })); })(window);"}],"posts":[{"title":"(简单)2347.最好的扑克手牌","slug":"leetcode/2347.最好的扑克手牌","date":"2023-02-20T14:32:12.000Z","updated":"2023-02-20T15:52:16.573Z","comments":true,"path":"posts/6925.html","link":"","permalink":"http://example.com/posts/6925.html","excerpt":"","text":"这里没有说返回什么值，只说什么情况下返回什么结果，所以我们可以借助js的工具帮忙判断：set是一个集合，集合中的数都是唯一的，可以当成不允许有重复值的数组用set可以帮我们判断数组中值重复的数量。内置函数add添加，has查找，delete删除，size长度map是哈希表，给定一个key值，绑定对应value。内置函数set添加，has查找，delete删除，size长度图示代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243var bestHand = function(ranks, suits) &#123; const suitsSet = new Set(); for (const suit of suits) &#123; suitsSet.add(suit); &#125; if (suitsSet.size === 1) &#123; return &quot;Flush&quot;; &#125; const h = new Map(); for (const rank of ranks) &#123; h.set(rank, (h.get(rank) || 0) + 1); &#125; if (h.size === 5) &#123; return &quot;High Card&quot;; &#125; for (const value of h.values()) &#123; if (value &gt; 2) &#123; return &quot;Three of a Kind&quot;; &#125; &#125; return &quot;Pair&quot;;&#125;;","categories":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/categories/%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://example.com/tags/leetcode/"}]},{"title":"横板跳跃小游戏笔记","slug":"games/横板跳跃游戏js","date":"2023-02-20T04:27:38.512Z","updated":"2023-02-20T16:00:04.210Z","comments":true,"path":"posts/3ba1.html","link":"","permalink":"http://example.com/posts/3ba1.html","excerpt":"","text":"初始化index.html1234&lt;canvas id=&#x27;canvas1&#x27;&gt;&lt;/canvas&gt;&lt;img id=&#x27;playerImage&#x27; src=&#x27;...&#x27;&gt;&lt;img id=&#x27;backgroundImage&#x27; src=&#x27;...&#x27;&gt;&lt;img id=&#x27;enemyImage&#x27; src=&#x27;...&#x27;&gt;css12345678910111213141516body &#123; background: black;&#125;#canvas1 &#123; /*background: #0000FF;*/ position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); border: 3px solid white;&#125;#playerImage,#backgroundImage,#enemyImage &#123; display: none;&#125;script.js匿名函数：没有定义名称的函数对象12345678910window.addEventListener(&#x27;load&#x27;,function()&#123; const canvas = document.getElementById(&#x27;canvas1&#x27;) const ctx = canvas.getContext(&#x27;2d&#x27;) canvas.width = 800 canvas.height=650 function animate()&#123; &#125;&#125;)这样建立好初始框架处理程序类监听键盘事件播放器类对监听事件做出反应单独的滚动类处理无休止的滚动敌人类定义敌人，函数handleEnemies创造/删除敌人函数displayStatusText展示提示文本，显示分数等1234567891011121314//处理键盘点击事件class InputHandler&#123;&#125;//对键盘监听事件做出反应class Player&#123;&#125;//处理无休止的滚动class background&#123;&#125;//敌人的定义class Enemy&#123;&#125;//创造/删除敌人function handleEnemies() &#123;&#125;//提示文本，如计算得分function displayStatusText()&#123;&#125;//动画演出function animate()&#123;&#125; 键盘点击事件的响应12345678910111213141516171819202122232425262728//InputHandler class InputHandler&#123; constructor() &#123; //追踪多个按键 this.key=[] window.addEventListener(&#x27;keydown&#x27;,e =&gt; &#123; if((e.key == &#x27;ArrowDown&#x27; || e.key == &#x27;ArrowUp&#x27; || e.key == &#x27;ArrowLeft&#x27; || e.key == &#x27;ArrowRight&#x27;)&amp;&amp; this.key.indexOf(e.key)=== -1 )&#123; this.key.push(e.key) console.log(this.key) &#125; &#125;) window.addEventListener(&#x27;keyup&#x27;,e =&gt; &#123; if(e.key == &#x27;ArrowDown&#x27; || e.key == &#x27;ArrowUp&#x27; || e.key == &#x27;ArrowLeft&#x27; || e.key == &#x27;ArrowRight&#x27; )&#123; this.key.splice(this.key.indexOf(e.key),1) console.log(this.key) &#125; &#125;) &#125; &#125; 键盘控制player状态移动首先将player基础结构设置好，代码略将input得到的keys数组绑定到player类上，此时点按/长按右键物体均可移动123if (input.keys.indexOf(&#x27;ArrowRight&#x27;)&gt;-1)&#123; this.speed = 5&#125;else &#123;this.speed = 0&#125;但是有个问题，只能绑定一个键，如果代码为123456if (input.keys.indexOf(&#x27;ArrowRight&#x27;)&gt;-1)&#123; this.speed = 5&#125;else &#123;this.speed = 0&#125;if (input.keys.indexOf(&#x27;ArrowLeft&#x27;)&gt;-1)&#123; this.speed = -5&#125;else &#123;this.speed = 0&#125;时物体只能左移，这是因为我按右键时满足第一个条件，speed应该＋5，但下面的判断不满足，+5被覆盖掉速度依然是0，我的小失误。正确做法：12345678910//动作if (input.keys.indexOf(&#x27;ArrowRight&#x27;)&gt;-1)&#123; this.speed = 5&#125;else if (input.keys.indexOf(&#x27;ArrowLeft&#x27;)&gt;-1)&#123; this.speed = -5&#125;else if(input.keys.indexOf(&#x27;ArrowUp&#x27;)&gt;-1)&#123; this.frameY = 0&#125;else if(input.keys.indexOf(&#x27;ArrowDown&#x27;)&gt;-1)&#123; this.frameY = 1&#125;else &#123;this.speed = 0&#125; 重力1234567891011121314151617this.vy = 0 //gravitythis.weight = 1//update //禁止二段跳！（vergil：**）else if(input.keys.indexOf(&#x27;ArrowUp&#x27;)&gt;-1 &amp;&amp; this.onGround())&#123; this.vy = -20 this.frameY = 0&#125;//垂直运动this.y +=this.vy//如果不在地面，赋予一个重力加速度if(!this.onGround())&#123; this.vy +=this.weight&#125;else &#123; this.vy = 0&#125; 无限背景无限背景的原理：在image1播放完毕后，仅仅显示image2一个画面的大小，马上拉回image11234567891011121314151617181920class Background&#123; constructor(gameWidth,gameHeight) &#123; this.x = 0 this.y = 0 this.width = 2400 this.height = 720 this.gameWidth = gameWidth this.gameHeight = gameHeight this.image = document.getElementById(&#x27;backgroundImage&#x27;) this.speed = 8 &#125; update()&#123; this.x -= this.speed if(this.x&lt;0-this.width) this.x=0 &#125; draw()&#123; ctx.drawImage(this.image, this.x, this.y, this.width, this.height) ctx.drawImage(this.image, this.x+this.width, this.y, this.width, this.height) &#125; &#125; 创建敌人123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263let enemies = [] class Enemy&#123; constructor(gameWidth,gameHeight) &#123; this.gameWidth = gameWidth this.gameHeight = gameHeight this.width = 160 this.height = 119 this.x = this.gameWidth this.y = this.gameHeight-this.height this.image = document.getElementById(&#x27;enemyImage&#x27;) this.frameX = 0 this.maxFrame = 5 this.frameTimer = 0 this.fps = 20 this.frameInterval = 1000/this.fps this.speed = 8 this.markedForDeletion = false &#125; update(deltatime)&#123; if(this.frameTimer &gt; this.frameInterval)&#123; if(this.frameX &gt;= this.maxFrame)&#123; this.frameX = 0 &#125;else this.frameX ++ this.frameTimer = 0 &#125;else &#123; this.frameTimer+=deltatime &#125; this.x -= this.speed if(this.x&lt;0-this.width) &#123; this.markedForDeletion = true score++ &#125; &#125; draw(context)&#123; context.linerWidth=5 context.strokeStyle = &#x27;white&#x27; context.beginPath() context.arc(this.x+this.width/2,this.y+this.width/2-20,this.width/3,0,Math.PI*2) context.stroke() context.drawImage(this.image, this.frameX * this.width, 0, this.width, this.height, this.x, this.y, this.width, this.height) &#125; restart()&#123; this.x=0 this.y=this.gameHeight-this.height this.maxFrame=8 this.frameY=0 &#125; &#125; //创造/删除敌人 function handleEnemies(deltaTime) &#123; if(enemyTimer&gt; enemyInterval+randomMyInterval)&#123; enemies.push(new Enemy(canvas.width, canvas.height)) enemyTimer = 0 &#125;else&#123; enemyTimer+=deltaTime &#125; enemies.forEach(object =&gt; &#123; object.update(deltaTime) object.draw(ctx) &#125;) // console.log(enemies) enemies = enemies.filter(object =&gt; !object.markedForDeletion) &#125; 得分板1234567//function displayStatusText context.textAlign=&#x27;left&#x27; context.font=&#x27;40px Helvetica&#x27; context.fillStyle=&#x27;black&#x27; context.fillText(&#x27;Score:&#x27;+score,20,50) context.fillStyle=&#x27;white&#x27; context.fillText(&#x27;Score:&#x27;+score,20,52) 碰撞检测原理：将player和enemy视作圆形，那么检测碰撞实质是检测两圆是否存在交点：两圆心的距离是否大于两圆半径之和为什么用圆形？因为存在player跳跃完毕后落到已经避开的enemy身上，而enemy精灵图中边角是不存在怪物的，这种判断就相当反直觉。为了提高准确性兼顾运行效率才选择用圆形代表碰撞体积12345678910111213141516//class Player update()enemies.forEach(enemy =&gt;&#123; const dx=(enemy.x+enemy.width/2-20)-(this.x+this.width/2) const dy=(enemy.y+enemy.height/2)-(this.y+this.height/2+20) const distance=Math.sqrt(dx*dx+dy*dy) &#125;) if(this.frameTimer &gt; this.frameInterval)&#123; this.frameTimer = 0 if(this.frameX&gt;=this.maxFrame)&#123; this.frameX=0 &#125;else&#123; this.frameX++ &#125; &#125;else&#123; this.frameTimer+=deltatime &#125; 结束在检测碰撞时，如果发生了碰撞，变量gameOver变为true，此时动画停止播放1234567let gameOver = false//player update enemy.forEach(object =&gt; &#123;&#125;) if(distance&lt;enemy.width/3+this.width/3)&#123; gameOver=true &#125;//function animateif(!gameOver)requestAnimationFrame(animate)结束后添加显示牌12345678// function displayStatusTextif(gameOver)&#123; context.textAlign=&#x27;center&#x27; context.fillStyle=&#x27;black&#x27; context.fillText(&#x27;Game Over,press Enter or swipe down to restart&#x27;,canvas.width/2,200) context.fillStyle=&#x27;white&#x27; context.fillText(&#x27;Game Over,press Enter or swipe down to restart&#x27;,canvas.width/2+2,202) &#125;重启游戏1234567891011//在键盘点击事件类继续添加响应if(e.key===&#x27;Enter&#x27;&amp;&amp;gameOver) restartGame()//添加对应的响应函数function restartGame()&#123; player.restart() background.restart() enemies = [] score = 0 gameOver = false animate(0) &#125;具体的响应无非是对照构造函数重新赋值，不再赘诉","categories":[{"name":"作品练手","slug":"作品练手","permalink":"http://example.com/categories/%E4%BD%9C%E5%93%81%E7%BB%83%E6%89%8B/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"}]},{"title":"射击小游戏笔记","slug":"games/射击小游戏js","date":"2023-02-20T01:41:29.692Z","updated":"2023-02-20T04:28:57.037Z","comments":true,"path":"posts/b72b.html","link":"","permalink":"http://example.com/posts/b72b.html","excerpt":"","text":"射击游戏笔记实例图链接：http://gyr.pub 如不能打开请手动输入网址！并将https换成http 点击乌鸦即可射落并得分，直至乌鸦到达终点游戏结束 最终代码index.html index.html 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;./style.css&quot;/&gt; &lt;/head&gt; &lt;body&gt; &lt;canvas id=&quot;collosionCanvas&quot;&gt;&lt;/canvas&gt; &lt;canvas id=&quot;canvas1&quot;&gt;&lt;/canvas&gt; &lt;script src=&quot;./script.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; style.css style.css 1234567891011121314151617body &#123; background: linear-gradient(145deg,yellow,green,blue); width: 100vw; height: 100vh; overflow: hidden;&#125;#canvas1 &#123; position: absolute; top: 0; left: 0; width: 100%; height: 100%;&#125;#collosionCanvas&#123; /* 把填充乌鸦的色块消除不显示 */ opacity: 0;&#125; script.js script.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195//主画布const canvas = document.getElementById(&#x27;canvas1&#x27;)const ctx = canvas.getContext(&#x27;2d&#x27;)canvas.width = window.innerWidthcanvas.height=window.innerHeight//碰撞画布const collosionCanvas = document.getElementById(&#x27;collosionCanvas&#x27;)const collosionCtx = collosionCanvas.getContext(&#x27;2d&#x27;)collosionCanvas.width = window.innerWidthcollosionCanvas.height=window.innerHeightlet timeToNextRaven = 0//设置生成乌鸦的间隔let ravenInterval = 500let lastTime = 0//记分板let score = 0ctx.font = &#x27;50px Impact&#x27;//游戏条件let gameOver = falsefunction drawGameOver()&#123; ctx.textAlign = &#x27;center&#x27; ctx.fillStyle = &#x27;black&#x27; ctx.fillText(&#x27;游戏结束！你的分数是：&#x27;+score,canvas.width/2,canvas.height/2) ctx.fillStyle = &#x27;white&#x27; ctx.fillText(&#x27;游戏结束！你的分数是：&#x27;+score,canvas.width/2+3,canvas.height/2+3)&#125;//乌鸦类let ravens = []class Raven &#123; constructor()&#123; this.spriteWidth = 271 this.spriteHeight = 194 this.sizeModifier = Math.random()*0.5+0.5 this.width = this.spriteWidth*this.sizeModifier this.height = this.spriteHeight*this.sizeModifier this.x=canvas.width this.y=Math.random()*(canvas.height-this.height) this.directionX = Math.random()*5+3 this.directionY = Math.random()*5-2.5 this.image = new Image() this.image.src = &#x27;../src/img/05/项目%205：傻瓜射击游戏.png&#x27; this.frame = 0 this.maxFrame = 4 this.timeSinceFlap = 0 //展翅频率|切换下一帧耗费毫秒数 this.flapInterval = Math.random()*50+50 //绘制碰撞画板 this.randomColors =[Math.floor(Math.random()*255),Math.floor(Math.random()*255),Math.floor(Math.random()*255)] this.color = &#x27;rgb(&#x27;+this.randomColors[0]+&#x27;,&#x27;+this.randomColors[1]+&#x27;,&#x27;+this.randomColors[2]+&#x27;)&#x27; this.hasTrail=Math.random()&gt;0.5 &#125; update(deltatime)&#123; if(this.y&lt;0 || this.y&gt;canvas.height-this.height)&#123; this.directionY = this.directionY*-1 &#125; this.x -=this.directionX this.y +=this.directionY if(this.x&lt; 0-this.width) this.markedForDeletion = true this.timeSinceFlap += deltatime if(this.timeSinceFlap &gt;= this.flapInterval) &#123; this.frame++ if(this.frame &gt; this.maxFrame)&#123; this.frame = 0 &#125;else &#123; this.frame++ &#125; this.timeSinceFlap = 0 if(this.hasTrail)&#123;//限制粒子效果只出现5个 for(let i=0;i&lt;5;i++)&#123; particles.push(new Particle(this.x,this.y,this.width,this.color)) &#125; &#125; &#125; if(this.x &lt; 0-this.width) gameOver = true &#125; draw()&#123; collosionCtx.fillStyle = this.color collosionCtx.fillRect(this.x,this.y,this.width,this.height) ctx.drawImage(this.image,this.frame*this.spriteWidth,0,this.spriteWidth,this.spriteHeight,this.x,this.y,this.width,this.height) &#125;&#125;let explosions = []class Explosion &#123; constructor(x,y,size)&#123; this.image = new Image() this.image.src = &#x27;../src/img/05/项目%205：尘云.png&#x27; this.spriteWidth = 200 this.spriteHeight = 179 this.x = x this.y = y this.size = size this.sound = new Audio() this.sound.src = &#x27;../sound/cloud/Ice%20attack%202.wav&#x27; this.timer = 0 this.frame=0 this.Maxframe = 5 this.frameInterval = 200 this.markedForDeletion = false &#125; update(detaltime)&#123; if(this.frame == 0)this.sound.play() this.timer +=detaltime if(this.timer&gt;this.frameInterval)&#123; this.frame++ this.timer=0 if(this.frame&gt;this.Maxframe)&#123; this.markedForDeletion = true &#125; &#125; &#125; draw()&#123; ctx.drawImage(this.image,this.frame*this.spriteWidth,0,this.spriteWidth,this.spriteHeight,this.x,this.y,this.size,this.size) &#125;&#125;function drawScore()&#123; ctx.fillStyle = &#x27;black&#x27; ctx.fillText(&#x27;Score:&#x27;+score,50,75) ctx.fillStyle = &#x27;white&#x27; ctx.fillText(&#x27;Score:&#x27;+score,50,80)&#125;// 乌鸦身体后的粒子效果let particles=[]class Particle&#123; constructor(x,y,size,color)&#123; this.size=size this.x=x+this.size/2 this.y=y+this.size/3 this.radius=Math.random()*this.size/10 this.maxRadius=Math.random()*20+35 this.markedForDeletion=false this.speedX=Math.random()*1+0.5 this.color=color &#125; update()&#123; this.x+this.speedX this.radius+=0.5 if(this.radius&gt;this.maxRadius-5) this.markedForDeletion=true &#125; draw()&#123; ctx.save() ctx.globalAlpha=1-this.radius/this.maxRadius ctx.beginPath() ctx.fillStyle=this.color ctx.arc(this.x,this.y,this.radius,0,Math.PI*2) ctx.fill() ctx.restore() &#125;&#125;window.addEventListener(&#x27;click&#x27;,function(e)&#123; const detectPixelColor = collosionCtx.getImageData(e.x,e.y,1,1) const pc = detectPixelColor.data ravens.forEach(object =&gt;&#123; if(object.randomColors[0]==pc[0]&amp;&amp;object.randomColors[1]==pc[1]&amp;&amp;object.randomColors[2]==pc[2])&#123; object.markedForDeletion = true score++ explosions.push(new Explosion(object.x,object.y,object.width)) &#125; &#125;)&#125;)function animate(timestamp)&#123; ctx.clearRect(0,0,canvas.width,canvas.height) collosionCtx.clearRect(0,0,canvas.width,canvas.height) //function animate //detaltime是该电脑刷新一次动画耗费的毫秒数 let deltatime = timestamp - lastTime lastTime = timestamp timeToNextRaven +=deltatime if(timeToNextRaven&gt;ravenInterval)&#123; ravens.push(new Raven()) timeToNextRaven = 0 // console.log(ravens) ravens.sort(function(a,b)&#123; return a.width-b.width &#125;) &#125; drawScore(); [...particles,...ravens,...explosions].forEach(object=&gt;&#123; object.update(deltatime) &#125;); [...particles,...ravens,...explosions].forEach(object=&gt;&#123; object.draw() &#125;); particles=particles.filter(object =&gt; !object.markedForDeletion) ravens=ravens.filter(object =&gt; !object.markedForDeletion) explosions=explosions.filter(object =&gt; !object.markedForDeletion) if(!gameOver) &#123;requestAnimationFrame(animate)&#125; else drawGameOver()&#125;animate(0) 设计流程页面初始化style.css12345678910111213body &#123; background: linear-gradient(to right,red,green,blue) width:100vw height:100vh overflow:hidden&#125;#canvas1 &#123; position:absolute top:0 left:0 width:100% height:100%&#125;index.js123&lt;body&gt; &lt;canvas id=&#x27;canvas1&#x27;&gt;&lt;/canvas&gt;&lt;body&gt;script.js1234const canvas = document.getElementById(&#x27;canvas1&#x27;)const ctx = canvas.getContext(&#x27;2d&#x27;)canvas.width=window.innerWidthcanvas.height=window.innerHeight流程：先用方块填充，看演示是否达到预期。再考虑方块换乌鸦1234567891011121314151617181920let ravens = []class Raven &#123; costructor()&#123; this.width=100 this.height=50 this.x=canvas.width this.y=Math.random()*(canvas.height-this.height) this.directionX = Math.random()*5+3 this.directionY = Math.random()*5-2.5 &#125; update()&#123; this.x -=this.directionX &#125; draw()&#123; ctx.fillRect(this.x,this.y,this.width,this.height) &#125;&#125;const raven = new Raven()创建动画123456function animate(timestamp)&#123; ctx.clearRect(0,0,canvas.width,canvas.height) console.log(&#x27;test&#x27;) requestAnimationFrame(animate)&#125;animate()timestamp时间戳：保证无论机器运行效率如何，新电脑和旧电脑都保证按照一定的时间运行动画（保证产生乌鸦的间隔是一致的）1234567891011let timeToNextRaven = 0//设置生成乌鸦的间隔let ravenInterval = 500let lastTime = 0//function animate//detaltime是该电脑刷新一次动画耗费的毫秒数let detaltime = timestamp - lastTimelastTime = timestampconsole.log(timestamp)//console.log(detaltime)timestamp（时间戳）打印结果 detaltime打印结果如图，该浏览器切换一次动画（1帧）需要消耗16ms将乌鸦对象创建进去12345678910//animate()timeToNextRaven+=detaltimeif(timeToNextRaven&gt;ravenInterval)&#123; ravens.push(new Raven()) timeToNextRaven=0 //报错 原因：timestamp最开始的值是undefined detaltime最开始的值是NaN console.log(ravens)&#125;//解决方法：给timestamp赋初始值0animate(0)实现每500ms生成一个乌鸦对象下一步是将创建的乌鸦对象（方块）显示在动画中展开语法：将ravens数组展开，赋值给一个新数组中，再遍历这个新数组绑定事件。至于为什么不直接用ravens数组？是因为后面还有explosions对象、particle对象也需要遍历绑定事件，造成代码的冗余1234567//注意逗号，否则...报错[...ravens].forEach(object = &gt; &#123; object.update()&#125;);[...ravens].forEach(object = &gt; &#123; object.draw()&#125;);删除已演出完毕的乌鸦对象1234567//class ravenupdate()&#123;//超过-width表示超出画面，标记删除 if(this.x&lt;0-this.width) this.markedForDeletion = true&#125;//function animateraven = raven.filter(object =&gt; !object.markedFormDeletion) 乌鸦的逻辑基本完毕，下一步引入精灵图，让乌鸦动起来1234567//construtorthis.image = new Image()this.image.src = &#x27;...&#x27;this.spriteWidth = 271this.spriteHeight = 194//drawctx.drawImage(...)将精灵图第一帧乌鸦图插入成功，剩下的是引入frame(帧)将乌鸦动起来引入帧1234567891011121314151617181920//constructorthis.frame = 0this.maxFrame = 4this.timeSinceFlap = 0this.flapInterval = 100//update //在触发上下边框时反弹回视图中 if(this.y&lt;0 || this.y&gt;canvas.height-this.height)&#123; this.directionY = this.directionY*-1 &#125; this.timeSinceFlap += deltatime if(this.timeSinceFlap &gt;= this.flapInterval) &#123; this.frame++ if(this.frame &gt; this.maxFrame)&#123; this.frame = 0 &#125;else &#123; this.frame++ &#125; this.timeSinceFlap = 0 &#125;记分功能1234567891011let score = 0ctx.font = &#x27;50px Impact&#x27;function drawScore()&#123; //实现阴影效果 ctx.fillstyle = &#x27;black&#x27; ctx.fillText(&#x27;Score:&#x27;+score,50,75) ctx.fillstyle = &#x27;white&#x27; ctx.fillText(&#x27;Score:&#x27;+score,50,80)&#125;//function animatedrawScore() 设计功能实现 获取鼠标点击位置 判断是否命中乌鸦 添加击中动画 增加score计数获取点击位置的坐标12345window.addEventListener(&#x27;click&#x27;,function(e)&#123; console.log(e.x,e.y) const detectPixelColor = ctx.getImageData(e.x,e.y,1,1) console.log(detectPixelColor)&#125;) 在画板上（ctx，不包括body）rgba为透明，那么只要给每个乌鸦在画板上添加颜色，根据颜色就能判断是否击中乌鸦了（赋予一个碰撞面积）1234567891011121314151617//碰撞画布const collosionCanvas = document.getElementById(&#x27;collosionCanvas&#x27;)const collosionCtx = collosionCanvas.getContext(&#x27;2d&#x27;)collosionCanvas.width = window.innerWidthcollosionCanvas.height=window.innerHeight//绘制碰撞画板//constructorthis.randomColors =[Math.floor(Math.random()*255),Math.floor(Math.random()*255),Math.floor(Math.random()*255)] this.color = &#x27;rgb(&#x27;+this.randomColors[0]+&#x27;,&#x27;+this.randomColors[1]+&#x27;,&#x27;+this.randomColors[2]+&#x27;)&#x27;draw()&#123; collosionCtx.fillStyle = this.color collosionCtx.fillRect(this.x,this.y,this.width,this.height)ctx.drawImage(this.image,this.frame*this.spriteWidth,0,this.spriteWidth,this.spriteHeight,this.x,this.y,this.width,this.height)&#125; 此时点击背景（白色）和乌鸦时得到的detectPixelColor如下，能够判断是否击中乌鸦 123456const pc = detectPixelColor.data//检测发生碰撞 if(object.randomColors[0]==pc[0]&amp;&amp;object.randomColors[1]==pc[1]&amp;&amp;object.randomColors[2]==pc[2])&#123; object.markedForDeletion = true score++ &#125; 这样乌鸦就能击中后消失并记分，但有时候没有反应，初步怀疑是循环调用update、draw等函数导致，还需要再优化添加爆炸效果(吐槽：看太多了，直接在markdown写完copy到HBuilderX里运行居然没出大错)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647let explosions = []class Explosion &#123; constructor(x,y,size)&#123; this.image = new Image() this.image.src = &#x27;...&#x27; this.spriteWidth = ... this.spriteHeight = ... this.x = x this.y = y this.size = size this.width=this.spriteWidth/...*size this.height=this.spriteHeight/2..*size this.sound = new Audio() this.sound.src = &#x27;...&#x27; this.timer = 0 this.frame=0 this.Maxframe = 5 this.frameInterval = 200 this.markedForDeletion = false &#125; update(detaltime)&#123; if(this.frame == 0)this.sound.play() this.timer +=detaltime if(this.timer&gt;this.frameInterval)&#123; this.frame++ this.timer=0 if(this.frame&gt;this.Maxframe)&#123; this.markedForDeletion = true &#125; &#125; &#125; draw()&#123; ctx.drawImage(this.image,this.frame*this.spriteWidth,0,this.spriteWidth,this.spriteHeight,this.x,this.y,this.size,this.size) &#125;&#125;window.addEventListener(&#x27;click&#x27;,function(e)&#123; ... explosions.push(new Explosion(x,y,size))&#125;)//animate [...explosions].forEach(object =&gt; &#123; object.update() object.draw() &#125;) explosions = explosions.filter(object =&gt; !object.markedForDeletion)如图，命中乌鸦后演示灰尘动画，音效正常，动画时乌鸦对象删除此时一个游戏已经初具雏形，可以添加一些规则，定义游戏的开始与结束123456789101112131415let gameOver = falsefunction drawGameOver()&#123; ctx.textAlign = &#x27;center&#x27; ctx.fillStyle = &#x27;black&#x27; ctx.fillText(&#x27;游戏结束！你的分数是：&#x27;+score,canvas.width,canvas.height)&#125; ctx.fillStyle = &#x27;white&#x27; ctx.fillText(&#x27;游戏结束！你的分数是：&#x27;+score,canvas.width+5,canvas.height+5)&#125;//explosion updateif(this.x&lt;0-this.width) gameOver = true//animateif(!gameOver) requestAnimationFrame(animate)else drawGameOver()当有一直乌鸦没有被击落直至离开屏幕，游戏结束拓展：粒子特效12345678910111213141516171819202122232425262728293031let particles = []class Particle &#123; constructor(x,y,size,color)&#123; this.size=size this.x = x this.y = y this.radius = Math.random()*this.size/10 this.maxRadius = Math.random()*20 +35 this.markedForDeletion = false this.speedX = Math.random()*1+0.5 this.color = color &#125; update()&#123; this.x += this.speedX this.radius += 0.2 if(this.radius&gt;this.maxRadius) this.markedForDeletion = true &#125; draw()&#123; ctx.save() ctx.globalAlpha = 1-this.radius/this.maxRadius ctx.beginPath() ctx.fillStyle = this.color ctx.arc(this.x,this.y,this.radius,0,Math.PI*2) ctx.fill() ctx.restore() &#125;&#125;//raven//updateparticle.push(new Particle(this.x,this.y,this.width,this.color))","categories":[{"name":"作品练手","slug":"作品练手","permalink":"http://example.com/categories/%E4%BD%9C%E5%93%81%E7%BB%83%E6%89%8B/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"}]},{"title":"Vue知识点复述","slug":"Vue面试考点","date":"2023-01-31T14:38:50.000Z","updated":"2023-02-13T13:00:55.776Z","comments":true,"path":"posts/6edd.html","link":"","permalink":"http://example.com/posts/6edd.html","excerpt":"","text":"vueMVVM的原理 View - 是 HTML 显示页面 ViewModel - 业务逻辑层：一切 JS 可视为业务逻辑，比如表单按钮提交，自定义事件的注册和处理逻辑都在 ViewModel 里面负责监听两边的数据 Model - 数据层对数据的处理，如增删改查基本逻辑是View-ViewModel-Model视图层通过中间层ViewModel接触Model，ViewModel是两层之间的桥梁实现？ Vue 中如何解析模板 Vue 中如何实现响应式vue2（浅响应式）：首先会遍历所有data，使用difinepriperty拦截所有属性当用户操作视图会触发set拦截器set首先会改变当前的数据，然后通知watch，让watch通知视图进行更新。视图重绘，再次从get中获取相应的数据修改data属性后，立刻被vue监听到，然后代理到vm属性上v-model、v-bindv-model用在表单中，方便获取表单数据。v-bind主要用于属性绑定双向绑定是个语法糖，实质上是value和input数据绑定和事件绑定vue生命周期创建、挂载、更新、销毁 什么是vue生命周期？Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载DOM-渲染、更新-渲染、卸载等一系列的过程，我们称这是 Vue 的生命周期。 vue生命周期的作用是什么Vue 所有的功能的实现都是围绕其生命周期进行的，在生命周期的不同阶段调用对应的钩子函数可以实现组件数据管理和DOM渲染两大重要功能。生命周期中有多个事件钩子，在控制整个vue实例的过程时更容易形成好的逻辑。 第一次页面加载会触发哪几个钩子？beforeCreate ， created ， beforeMount ，mounted 这几个钩子 简述每个周期具体适合哪些场景？ beforeCreate：创建前，此阶段为实例初始化之后，this指向创建的实例，此时的数据观察事件机制都未形成，不能获得DOM节点。data，computed，watch，methods 上的方法和数据均不能访问。可以在这加个loading事件。 created：创建后，此阶段为实例已经创建，完成数据（data、props、computed）的初始化导入依赖项。可访问 data computed watch methods 上的方法和数据。初始化完成时的事件写在这里，异步请求也适宜在这里调用（请求不宜过多，避免白屏时间太长）。可以在这里结束loading事件，还做一些初始化，实现函数自执行。未挂载DOM，若在此阶段进行DOM操作一定要放在Vue.nextTick()的回调函数中。 beforeMount：挂载前，虽然得不到具体的DOM元素，但vue挂载的根节点已经创建，下面vue对DOM的操作将围绕这个根元素继续进行。beforeMount这个阶段是过渡性的，一般一个项目只能用到一两次。 mounted：挂载，完成创建vm.$el，和双向绑定完成挂载DOM和渲染，可在mounted钩子函数中对挂载的DOM进行操作。可在这发起后端请求，拿回数据，配合路由钩子做一些事情。 beforeUpdate：数据更新前，数据驱动DOM。在数据更新后虽然没有立即更新数据，但是DOM中的数据会改变，这是vue双向数据绑定的作用。可在更新前访问现有的DOM，如手动移出添加的事件监听器。 updated：数据更新后，完成虚拟DOM的重新渲染和打补丁。组件DOM已完成更新，可执行依赖的DOM操作。注意：不要在此函数中操作数据（修改属性），会陷入死循环。 activated：在使用vue-router时有时需要使用&lt;keep-alive&gt;&lt;/keep-alive&gt;来缓存组件状态，这个时候created钩子就不会被重复调用了。如果我们的子组件需要在每次加载的时候进行某些操作，可以使用activated钩子触发。 deactivated：&lt;keep-alive&gt;&lt;/keep-alive&gt;组件被移除时使用。 beforeDestroy：销毁前，可做一些删除提示，如：您确定删除xx吗？ destroyed：销毁后，当前组件已被删除，销毁监听事件，组件、事件、子实例也被销毁。这时组件已经没有了，无法操作里面的任何东西了。 为什么data是函数型涉及到浅拷贝和深拷贝的关系，data如果是对象，父子组件中的data是浅拷贝，这样其中一个发生改变也会对另一个对象中的数据产生影响，不利于实际开发。因此采用函数型，是深拷贝，组件间数据互不干扰 vue组件vue组件化，就是把页面拆分成多个组件，每个组件依赖的 CSS、JS、模板、图片等资源放在一起开发和维护。因为组件是资源独立的，所以组件在系统内部可复用，组件和组件之间可以嵌套，如果项目比较复杂，可以极大简化代码量，并且对后期的需求变更和维护也更加友好。区别：全局组件是挂载在 Vue.options.components 下，而局部组件是挂载在 vm.$options.components 下，这也是全局注册的组件能被任意使用的原因。局部引入先import，再 12345678910&lt;html&gt; &lt;app-head&gt;&lt;/html&gt;&lt;script&gt;export default &#123; components: &#123; AppHead &#125;&#125;&lt;/script&gt; vue组件间的传值子组件和父组件通讯，通过调用父组件给组件自定义属性值来实现传数据可以用v-bind，自定义属性值1.props/$emit组合方式：子组件通过定义props值拿到父组件传给子组件的属性来获取；子组件通过使用$emit方法调用父组件的方法； 2.$attrs/$listeners组合方式：子组件可以通过$attrs属性中的值拿到父组件传给子组件的属性值，它里边存储的是props之外的属性值； 3.$parent方法获取父组件中的数据和方法 父组件主动获取子组件数据1.ref/$refs方式，通过给引入的组件定义一个ref属性，然后就可以通过$refs结合该属性值得到当前组件的实例 2.ref/$children属性，给组件定义ref值后，当前组件实例中会在this.$children中拿到所有定义了ref的组件数组，我们在通过下标进行获取某个子组件的方法后者属性值。 vuex、localstorage等[[Learn/笔记/vuex]]vuex中的state可以全局管理数据 ref、prop、slot（scope）vue-cliVue CLI 是一个基于 Vue.js 进行快速开发的完整系统，可以快速搭建出vue项目。致力于将 Vue 生态中的工具基础标准化。快速搭建一个新项目1vue create [项目名]图形化界面管理项目1vue ui vue-router路由hash和history的区别？histroy不带# 方便第三方插件引入，刷新后会404，通常需要后端配置解决这个问题 hash带# 传统使用hash 不方便第三方插件引入 Axiosaxios的好处？（promise）axios是一个基于Promise的HTTP客户端，可以用在浏览器和node.js中，向服务器发送AJAX请求进行数据交换，是现在前端最热门的请求工具。同步思维异步操作，可以省去嵌套，什么时候轮到ajax执行完什么时候再调用then，等于多了个包装 axios拦截器原理：axios创建时有两个参数：configintercepters对象有request、response两个属性值，在这里绑定拦截器拦截器的绑定，请求拦截器在dispatch前，头部添加，相应拦截器在dispatch后，用push推送 vuexstate(数据保存)mutation（保存同步函数）action（保存异步操作函数）moduel（模组）getter（对原数据进行处理，不改变原数据） mockjs网络localstorage、cookie cookie：主要用来保存登录信息，比如登录某个网站市场可以看到“记住密码”这就是通过cookie中存入一段辨别用户身份的数据来实现的 sessionStorage：会话，是可以将一部分数据在当前的会话中保存下来，刷新页面数据依旧存在。但是页面关闭,sessionStorage中的数据就会被清空。 localStorage：是HTML5标准找那个新加入的技术，当然早在IE6时代就有一个userData的东西用于本地存储，当时考虑到浏览器的兼容性，更通用的方案是flash，如今localStorage被大多数浏览器所支持。localStorage中的键值对总是以字符串的形式存储。localStorage类似[sessionStorage](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/Window/sessionStorage)，但其区别在于：存储在localStorage 的数据可以长期保留； 补充：同源：协议相同/域名相同/端口相同cookie 要表示唯一的一个cookie值需要：name、domain、path 一个cookie就是一个小型的文本文件 虽然cookie保存在浏览器端，但是一般是在服务器端设置的。 可以在HTTP返回体里，通过设置Set-Cookie来告诉浏览器端所要存储的cookie。 用来保存客户浏览器请求服务器页面的请求信息 localstorage、sessionstoragelocalstorage时间无限sessionstorage时间有限 localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。 sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。也就是说只要这个浏览器窗口没有关闭，即使刷新页面或进入同源另一页面，数据仍然存在。关闭窗口后，sessionStorage即被销毁 localStorage也受同源策略的限制。 localStorage和sessionStorage都具有相同的操作方法，如setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。原型链原型（prototype）是绑定在构造函数上的一个属性，它的属性值是一个对象，我们画图时经常表述为原型对象首先，prototype对象中默认有constructor属性，属性值指回它的构造函数。那么prototype具体的作用是什么呢？在prototype中我们可以添加自定义属性和方法，也就是常说的将属性和方法挂载在原型上面，这样构造函数实例对象就能够使用这些属性和方法了原型链是函数继承多次后原型不断挂载形成的链条，通过proto来连接proto又称隐式原型，是实例对象上的属性，它指向和实例对象构造函数prototype一样的内存空间。原型链的用处又是什么呢？在调用实例对象属性和方法中可以通过原型链来查找：先查看该对象有没有，再顺着原型链往上找，直到找到Object.prototype，如果还没有则输出undefined。instance也是运用了这个原理，查看两个实例对象有没有指向同一个实例对象","categories":[{"name":"日常学习","slug":"日常学习","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}]},{"title":"vue2学习笔记","slug":"Vue2知识点","date":"2022-12-29T09:22:19.000Z","updated":"2023-02-13T13:00:55.774Z","comments":true,"path":"posts/78a7.html","link":"","permalink":"http://example.com/posts/78a7.html","excerpt":"","text":"Vue2 学习笔记 Vue核心Vue简介官网 英文官网：https://vuejs.org/ 中文官网：https://cn.vuejs.org/ 1.1.2 简介 动态构建用户界面的渐进式JavaScript框架 1.1.3 Vue特点 采用组件化模式，提高代码复用率、且让代码更好维护 声明式编码，让编码人员无需直接操作DOM，提高开发效率 使用虚拟DOM+优秀的Diff算法,尽可能复用节点 初始Vue小结 使用Vue 创建Vue实例，传入配置对象 容器内代码符合html规范 容器内代码称之为【Vue模板】 注意事项 Vue实例和容器一一对应 开发中Vue和组件配合使用 &#123;&#123;XXX&#125;&#125;中XXX写的是Js表达式，且XXX可以自动读取到data中的所有属性 data中的数据发生改变，页面中使用该数据的地方会自动更新 区分Js代码和 Js表达式 Js表达式： 一个表达式会产生一个值，可以放在任何一个需要值的地方 示例 a a + b demo(a) x === y ? ‘a’ : ‘b’ Js代码（语句） if(){} for(){} 1.2.2 代码实例12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;初始Vue&lt;/title&gt; &lt;!-- 引入Vue --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 容器准备 --&gt; &lt;div id=&quot;root&quot;&gt; &lt;h1&gt;Hello: &#123;&#123;name&#125;&#125;&lt;/h1&gt; &lt;h1&gt;age: &#123;&#123;age&#125;&#125;&lt;/h1&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; //阻止 vue 在启动时生成生产提示 Vue.config.productionTip = false //创建Vue实例 =&gt; 传入配置对象 new Vue(&#123; //el =&gt; 指定当前Vue实例为哪个容器服务，值通常为css选择器字符串 el: &#x27;#root&#x27;, //data =&gt; 存储数据，数据供el所指定的容器使用 data: &#123; name:&#x27;Vue&#x27;, age: 19 &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 模板语法分类 插值语法 功能：用于解析标签体内容 写法：&#123;&#123;XXX&#125;&#125;,XXX写的是Js表达式，且XXX可以自动读取到data中的所有属性 指令语法 功能：用于解析标签（包括：标签属性、标签体内容、绑定事件） 举例 1234567&lt;a v-bind:href=&quot;xxx&quot;&gt;&lt;/a&gt;&lt;!--等价于--&gt;&lt;a :href=&quot;xxx&quot;&gt;&lt;/a&gt;&lt;!-- xxx写js表达式，且可以读取data中的所有属性 Vue将xxx当成js表达式执行 --&gt; 代码实例 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;模板语法&lt;/title&gt; &lt;!-- 引入Vue --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 容器准备 --&gt; &lt;div id=&quot;root&quot;&gt; &lt;!-- 标签体内 --&gt; &lt;h1&gt;插值语法&lt;/h1&gt; &lt;h3&gt;Hello,&#123;&#123;name&#125;&#125;&lt;/h3&gt; &lt;hr /&gt; &lt;!-- 标签属性 --&gt; &lt;h1&gt;指令语法&lt;/h1&gt; &lt;a v-bind:href=&quot;school.url.toUpperCase()&quot;&gt;点我去&#123;&#123;school.name&#125;&#125;学习1&lt;/a&gt; &lt;a :href=&quot;school.url&quot;&gt;点我去&#123;&#123;school.name&#125;&#125;学习2&lt;/a&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; //阻止 vue 在启动时生成生产提示 Vue.config.productionTip = false; new Vue(&#123; el: &quot;#root&quot;, data: &#123; name: &quot;Jack&quot;, school: &#123; name: &quot;bilibili&quot;, url: &quot;https://www.bilibili.com&quot;, &#125;, &#125;, &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 数据绑定 分类 单向绑定（v-bind）:数据只能从data流向页面 双向绑定（v-model):数据不仅能从data流向页面，还可以从页面流向data。 注意事项 双向绑定一般都应用在表单类(form)元素上（如：input、select等） v-model:value可以简写为v-model,因为v-model默认收集的就是value值。 代码实例 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;数据绑定&lt;/title&gt; &lt;!-- 引入Vue --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 容器准备 --&gt; &lt;div id=&quot;root&quot;&gt; &lt;!-- 普通写法 --&gt; 单向数据绑定：&lt;input type=&quot;text&quot; v-bind:value=&quot;name&quot;&gt;&lt;br/&gt; 双向数据绑定：&lt;input type=&quot;text&quot; v-model:value=&quot;name&quot;&gt;&lt;br/&gt; &lt;!-- v-model只能应用在表单类元素上（输入类元素上） --&gt; &lt;!-- 简写 --&gt; 单向数据绑定：&lt;input type=&quot;text&quot; :value=&quot;name&quot;&gt;&lt;br/&gt; 双向数据绑定：&lt;input type=&quot;text&quot; v-model=&quot;name&quot;&gt;&lt;br/&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; //阻止 vue 在启动时生成生产提示 Vue.config.productionTip = false; new Vue(&#123; el: &quot;#root&quot;, data: &#123; name: &quot;Jack&quot;, &#125;, &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; el 和 data的两种写法 el的两种写法 new Vue()的时候配置el属性 先创建Vue实例，随后通过vm.$mount(’挂载的容器‘)指定el的值 data的两种写法 对象式 函数式（写成普通函数 =&gt; this对象是当前的Vue实例） 代码实例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;数据绑定&lt;/title&gt; &lt;!-- 引入Vue --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 容器准备 --&gt; &lt;div id=&quot;root&quot;&gt; &lt;h1&gt;Hello,&#123;&#123;name&#125;&#125;&lt;/h1&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; //阻止 vue 在启动时生成生产提示 Vue.config.productionTip = false; // el的两种写法 /* const v = new Vue(&#123; //更换写法使用Vue自身的属性$mount() // 写法一：el:&#x27;#root&#x27;, // el:&#x27;#root&#x27;, data:&#123; name:&#x27;Jack&#x27; &#125; &#125;) // 写法二：$mount() // $mount()写法更灵活 v.$mount(&quot;#root&quot;) */ //data的两种写法 new Vue(&#123; el:&#x27;#root&#x27;, // 第一种写法：对象式写法 // data:&#123; // name:&#x27;jack&#x27; // &#125; // 第二种写法：函数式写法(写成普通函数) // data:function()&#123; data()&#123; return &#123; name:&#x27;Jack&#x27; &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 在我们学习到组件后，data只能写成函数式原因：组件实例化过程中，vue最终都会通过Vue.extend()构成组件实例如果data是对象，当我们创建两个组件实例，若两实例共用同一个引入的组件，则它们的data值会共享。因为两者共用了同一个内存地址如果采用函数的形式则不会出现这种情况，函数返回的对象内存地址并不相同源码位置：/vue-dev/src/core/util/options.js /vue-dev/src/core/instance/init.js 1.5 MVVM模型 MVVM模型解释 View - 是 HTML 显示页面 ViewModel - 业务逻辑层：一切 JS 可视为业务逻辑，比如表单按钮提交，自定义事件的注册和处理逻辑都在 ViewModel 里面负责监听两边的数据 Model - 数据层对数据的处理，如增删改查基本逻辑是View-ViewModel-Model视图层通过中间层ViewModel接触Model，ViewModel是两层之间的桥梁 注意事项 data中的所有属性，最后都出现在vm上 vm上的所有属性及Vue原型上的所有属性，在Vue模板中都可以直接使用 实现原理vue2（浅响应式）： 首先vue会遍历所有data，使用difinepriperty拦截所有属性 当用户操作视图会触发set拦截器 set首先会改变当前的数据，然后通知watch，让watch通知视图进行更新。 视图重绘，再次从get中获取相应的数据修改data属性后，立刻被vue监听到，然后代理到vm属性上 数据代理 理解：通过一个对象代理拎出一个对象中的属性的操作（读/写） 原理解析图 Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。 Vm中的数据代理 通过vm对象来代理data对象中属性的操作（读/写） Vue中数据代理的好处 更加方便的操作data中的数据 基本原理 通过Object.definePorperty()把data对象中所有属性添加到vm上 为每一个添加到vm上的属性指定一个getter/setter 在getter/setter内部去操作（读/写）data中对应的属性 事件处理事件的基本使用 使用v-on:XXX 或者@XXX绑定事件，其中XXX是事件名 事件的回调需要配置在methods对象中，最终会在vm上 methods中配置的函数，使用普通函数，若使用箭头函数 =&gt; ，this 不再是vm methods中配置的函数，都是被Vue所管理的函数，this的指向是vm 或 组件实例对象 @click=&quot;demo&quot;和@click=&quot;demo($event)&quot;效果一致，但是后者可以传参 代码示例12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;事件的基本使用&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;h1&gt;欢迎来到&#123;&#123;name&#125;&#125;&lt;/h1&gt; &lt;button v-on:click=&quot;showInfo1&quot;&gt;点我提示信息(不传参)&lt;/button&gt; &lt;!-- 简写 --&gt; &lt;button @click=&quot;showInfo2(666,$event)&quot;&gt;点我提示信息(传参)&lt;/button&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; //阻止 vue 在启动时生成生产提示 Vue.config.productionTip = false; new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; name:&#x27;hhu&#x27; &#125;, methods: &#123; showInfo1(event)&#123; console.log() console.log(this) //此处普通函数的this是vm alert(&quot;Hello Student!&quot;) &#125;, showInfo2(number,event)&#123; console.log(event.target.innerText) console.log(number) alert(&quot;Hello Student!!&quot;) &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 事件修饰符 prevent: 阻止默认事件 stop: 阻止事件冒泡 once: 事件只触发一次 capture: 使用事件的捕获模式 capture事件修饰符的作用是给元素添加一个监听器，当元素发生冒泡时，先触发带有该修饰符的元素。 self: 只有event.target是当前操作元素时才触发事件 关于.stop和.self的区别，前者是防止事件冒泡，后者则是忽略了事件冒泡和事件捕获的影响。 passive: 事件的默认行为立即执行，无需等待事件回调执行完毕 代码示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;事件修饰符&lt;/title&gt; &lt;!-- 引入Vue --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;style&gt; *&#123; margin-top: 20px; &#125; .demo1&#123; height: 50px; background-color: skyblue; &#125; .box1&#123; padding: 5px; background-color: skyblue; &#125; .box2&#123; padding: 5px; background-color: orange; &#125; .list&#123; width: 200px; height: 200px; background-color: peru; overflow: auto; &#125; li&#123; height: 100px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 准备好一个容器--&gt; &lt;div id=&quot;root&quot;&gt; &lt;h2&gt;欢迎来到&#123;&#123;name&#125;&#125;学习&lt;/h2&gt; &lt;!-- 阻止默认事件（常用） --&gt; &lt;a href=&quot;http://www.atguigu.com&quot; @click.prevent=&quot;showInfo&quot;&gt;点我提示信息&lt;/a&gt; &lt;!-- 阻止事件冒泡（常用） --&gt; &lt;div class=&quot;demo1&quot; @click=&quot;showInfo&quot;&gt; &lt;button @click.stop=&quot;showInfo&quot;&gt;点我提示信息&lt;/button&gt; &lt;!-- 修饰符可以连续写 --&gt; &lt;!-- &lt;a href=&quot;http://www.bilibili.com&quot; @click.prevent.stop=&quot;showInfo&quot;&gt;点我提示信息&lt;/a&gt; --&gt; &lt;/div&gt; &lt;!-- 事件只触发一次（常用） --&gt; &lt;button @click.once=&quot;showInfo&quot;&gt;点我提示信息&lt;/button&gt; &lt;!-- 使用事件的捕获模式 --&gt; &lt;div class=&quot;box1&quot; @click.capture=&quot;showMsg(1)&quot;&gt; div1 &lt;div class=&quot;box2&quot; @click=&quot;showMsg(2)&quot;&gt; div2 &lt;/div&gt; &lt;/div&gt; &lt;!-- 只有event.target是当前操作的元素时才触发事件； --&gt; &lt;div class=&quot;demo1&quot; @click.self=&quot;showInfo&quot;&gt; &lt;button @click=&quot;showInfo&quot;&gt;点我提示信息&lt;/button&gt; &lt;/div&gt; &lt;!-- 事件的默认行为立即执行，无需等待事件回调执行完毕； --&gt; &lt;ul @wheel.passive=&quot;demo&quot; class=&quot;list&quot;&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。 new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; name:&#x27;hhu&#x27; &#125;, methods:&#123; showInfo(e)&#123; alert(&#x27;Hello Student！&#x27;) // console.log(e.target) &#125;, showMsg(msg)&#123; console.log(msg) &#125;, demo()&#123; for (let i = 0; i &lt; 100000; i++) &#123; console.log(&#x27;#&#x27;) &#125; console.log(&#x27;累坏了&#x27;) &#125; &#125; &#125;) &lt;/script&gt;&lt;/html&gt; 键盘事件 Vue中常用的案件别名 回车 =&gt; enter 删除 =&gt; delete(捕获“删除”和“退格”键) 退出 =&gt; esc 空格 =&gt; space 换行 =&gt; tab(特殊，必须配合keydown去使用) 上 =&gt; up 下 =&gt; down 左 =&gt; left 右 =&gt; right Vue未提供别名的按键，可以使用按键原始的key值去绑定，但注意要转为kebab-case（短横线命名） 系统修饰键（用法特殊）：ctrl、alt、shift、meta 配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发 配合keydown使用：正常触发事件 可以使用keyCode去指定具体的按键（不推荐） Vue.config.keyCodes.自定义键名 = 键码 =&gt; 定制按键别名 代码示例 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;键盘事件&lt;/title&gt; &lt;!-- 引入Vue --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 准备好一个容器--&gt; &lt;div id=&quot;root&quot;&gt; &lt;h2&gt;欢迎来到&#123;&#123;name&#125;&#125;学习&lt;/h2&gt; &lt;input type=&quot;text&quot; placeholder=&quot;按下回车提示输入&quot; @keydown.huiche=&quot;showInfo&quot;&gt; &lt;/div&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。 Vue.config.keyCodes.huiche = 13 //定义一个别名按键 new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; name:&#x27;hhu&#x27; &#125;, methods: &#123; showInfo(e)&#123; // console.log(e.key,e.keyCode) console.log(e.target.value) &#125; &#125;, &#125;) &lt;/script&gt;&lt;/html&gt; 修饰符可以连续写 系统修饰符后可以接其他按键 =&gt; 按下特定案件才能触发事件 计算属性与监视计算属性-computed 姓名案例实现 插值语法实现1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;姓名案例（插值语法实现）&lt;/title&gt; &lt;!-- 引入Vue --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 准备好一个容器--&gt; &lt;div id=&quot;root&quot;&gt; last name: &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt;&lt;br/&gt; first name: &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt;&lt;br/&gt; whole name: &lt;span&gt;&#123;&#123; lastName.slice(0,3) &#125;&#125;-&#123;&#123; firstName &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。 new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; lastName:&#x27;张&#x27;, firstName:&#x27;三&#x27; &#125; &#125;) &lt;/script&gt;&lt;/html&gt; slice()和splice()的区别slice(start,end)：方法可从已有数组中返回选定的元素，返回一个新数组，包含从start到end（不包含该元素）的数组元素start参数：必须，规定从何处开始选取，如果为负数，规定从数组尾部算起的位置，-1是指最后一个元素。end参数：可选（如果该参数没有指定，那么切分的数组包含从start倒数组结束的所有元素，如果这个参数为负数，那么规定是从数组尾部开始算起的元素）该方法不会改变原数组，而是返回一个子数组，如果想删除数组中的一段元素，应该使用Array.splice()方法。 splice()：该方法向或者从数组中添加或者删除项目，返回被删除的项目。index参数：必须，整数，规定添加或者删除的位置，使用负数，从数组尾部规定位置。howmany参数：必须，要删除的数量，如果为0，则不删除项目。tem1,…itemX参数：可选，向数组添加的新项目。 methods实现 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;姓名案例（methods实现）&lt;/title&gt; &lt;!-- 引入Vue --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 准备好一个容器--&gt; &lt;div id=&quot;root&quot;&gt; last name: &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt;&lt;br/&gt; first name: &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt;&lt;br/&gt; whole name: &lt;span&gt;&#123;&#123; fullName() &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。 new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; lastName:&#x27;张&#x27;, firstName:&#x27;三&#x27; &#125;, methods: &#123; fullName() &#123; return this.lastName + &#x27;-&#x27; + this.firstName; &#125; &#125; &#125;) &lt;/script&gt;&lt;/html&gt; 计算属性实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;姓名案例（计算属性实现）&lt;/title&gt; &lt;!-- 引入Vue --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 准备好一个容器--&gt; &lt;div id=&quot;root&quot;&gt; last name: &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt;&lt;br/&gt; first name: &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt;&lt;br/&gt; whole name: &lt;span&gt;&#123;&#123; fullName &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。 new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; lastName:&#x27;张&#x27;, firstName:&#x27;三&#x27; &#125;, computed: &#123; fullName:&#123; //get作用：当读取fullName时，get就会被调用，且返回值就作为fullName的值 //get调用时机： //1、初次读取fullName时 //2、所依赖的数据发生变化时 get()&#123; return this.lastName + &#x27;-&#x27; + this.firstName &#125;, //set调用时机： fullName被修改时 set(value) &#123; const arr = value.split(&#x27;-&#x27;) lastName = arr[0] firstName = arr[1] &#125; &#125; &#125; &#125;) &lt;/script&gt;&lt;/html&gt; 计算属性简写(只考虑读取计算属性时) 123456789101112131415161718192021222324new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; lastName:&#x27;张&#x27;, firstName:&#x27;三&#x27; &#125;, computed: &#123; //完整写法 /* fullName:&#123; get()&#123; return this.lastName + &#x27;-&#x27; + this.firstName &#125;, set(value) &#123; const arr = value.split(&#x27;-&#x27;) lastName = arr[0] firstName = arr[1] &#125; &#125; */ //简写形式 fullName()&#123; return this.lastName + &#x27;-&#x27; + this.firstName &#125; &#125; &#125;) 计算属性 定义：要用的属性不存在，要通过已有属性计算得来 原理：底层借助了Object.defineProperty() 方法提供的getter和setter get()函数执行时机 初次读取数据时 当依赖的数据发生改变时会被再次调用 优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试方便 注意事项 计算属性最终会出现在vm上，直接读取即可 如果计算属性要被修改，必须要写set()函数去响应修改，并且set()中要引起计算时所依赖的数据发生改变 监视属性-watch 天气案例 天气案例（methods实现） 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;天气案例&lt;/title&gt; &lt;!-- 引入Vue --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 准备好一个容器--&gt; &lt;div id=&quot;root&quot;&gt; &lt;h2&gt;今天天气很&#123;&#123;info&#125;&#125;&lt;/h2&gt;&lt;br&gt; &lt;button @click=&quot;changeWeather&quot;&gt;点击切换天气&lt;/button&gt; &lt;/div&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。 new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; isHot:true &#125;, computed: &#123; info()&#123; return this.isHot ? &#x27;炎热&#x27; : &#x27;寒冷&#x27; &#125; &#125;, methods: &#123; changeWeather() &#123; this.isHot = !this.isHot &#125; &#125;, &#125;) &lt;/script&gt;&lt;/html&gt; 天气案例（监视属性） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;天气案例(监视属性)&lt;/title&gt; &lt;!-- 引入Vue --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 准备好一个容器--&gt; &lt;div id=&quot;root&quot;&gt; &lt;h2&gt;今天天气很&#123;&#123;info&#125;&#125;&lt;/h2&gt; &lt;br /&gt; &lt;button @click=&quot;changeWeather&quot;&gt;点击切换天气&lt;/button&gt; &lt;/div&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; Vue.config.productionTip = false; //阻止 vue 在启动时生成生产提示。 const vm = new Vue(&#123; el: &quot;#root&quot;, data: &#123; isHot: true, &#125;, computed: &#123; info() &#123; return this.isHot ? &quot;炎热&quot; : &quot;寒冷&quot;; &#125;, &#125;, methods: &#123; changeWeather() &#123; this.isHot = !this.isHot; &#125;, &#125;, // watch: &#123; // isHot: &#123; // immediate: true, //初始化时让handler调用 // handler(newValue, oldValue) &#123; // console.log(&quot;isHot被修改了&quot;, newValue, oldValue); // &#125;, // &#125;, // &#125;, &#125;); vm.$watch(&quot;isHot&quot;, &#123; handler(newValue, oldValue) &#123; console.log(&quot;isHot被修改了&quot;, newValue, oldValue); &#125;, &#125;); &lt;/script&gt;&lt;/html&gt; 监视属性watch 当被监视的属性变化时，回调函数自动调用，进行相关操作 监事的属性必须存在，才能进行监视 监视的两种写法 new Vue时传入watch配置 通过vm.$watch() 监视(这个先执行) 深度监视 Vue中的watch默认不监测对象内部值的改变 配置deep:true可以监测对象内部值的改变 简写形式（只有handler()函数时） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;天气案例(监视简写)&lt;/title&gt; &lt;!-- 引入Vue --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 准备好一个容器--&gt; &lt;div id=&quot;root&quot;&gt; &lt;h2&gt;今天天气很&#123;&#123;info&#125;&#125;&lt;/h2&gt; &lt;br /&gt; &lt;button @click=&quot;changeWeather&quot;&gt;点击切换天气&lt;/button&gt; &lt;/div&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; Vue.config.productionTip = false; //阻止 vue 在启动时生成生产提示。 const vm = new Vue(&#123; el: &quot;#root&quot;, data: &#123; isHot: true &#125;, computed: &#123; info() &#123; return this.isHot ? &quot;炎热&quot; : &quot;寒冷&quot;; &#125;, &#125;, methods: &#123; changeWeather() &#123; this.isHot = !this.isHot; &#125;, &#125;, watch: &#123; //正常写法 /* isHot: &#123; immediate: true, //初始化时让handler调用 deep:true, handler(newValue, oldValue) &#123; console.log(&quot;isHot被修改了&quot;, newValue, oldValue); &#125;, &#125;, */ //简写 isHot(newValue,oldValue)&#123; console.log(&quot;isHot被修改了&quot;, newValue, oldValue); &#125; &#125;, &#125;) //正常写法 /* vm.$watch(&#x27;isHot&#x27;,&#123; immediate:true, //初始化时让handler调用一下 deep:true,//深度监视 handler(newValue,oldValue)&#123; console.log(&#x27;isHot被修改了&#x27;,newValue,oldValue) &#125; &#125;) */ //简写 /* vm.$watch(&#x27;isHot&#x27;,(newValue,oldValue)=&gt;&#123; console.log(&#x27;isHot被修改了&#x27;,newValue,oldValue,this) &#125;) */ &lt;/script&gt;&lt;/html&gt; computed和watch的区别 computed能完成的功能，watch也可以完成 watch能完成的功能，computed不一定能完成。例如：watch可以进行异步操作 两个重要的小原则 所有被Vue管理的函数，最好写成普通函数，这样this的指向才是vm 或者 组件实例对象 所有不被Vue所管理的函数（定时器的回调函数、Ajax的回调函数、Promise的回调函数等）最好写成箭头函数，这样this的指向才是vm 或者 组件实例对象 绑定样式 class样式 写法:class=&quot;xxx&quot;,xxx可以是字符串、对象、数组 字符串写法适用于：类名不确定，需要动态获取 对象写法适用于：要绑定多个样式，个数不确定，名字也不确定 数组写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用 style样式 :style=&quot;&#123;fontSize:xxx&#125;&quot;，其中xxx是动态值 :style=[a,b]，其中a、b都是样式对象 代码示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;绑定样式&lt;/title&gt; &lt;style&gt; .basic&#123; width: 400px; height: 100px; border: 1px solid black; &#125; .happy&#123; border: 4px solid red;; background-color: rgba(255, 255, 0, 0.644); background: linear-gradient(30deg,yellow,pink,orange,yellow); &#125; .sad&#123; border: 4px dashed rgb(2, 197, 2); background-color: gray; &#125; .normal&#123; background-color: skyblue; &#125; .atguigu1&#123; background-color: yellowgreen; &#125; .atguigu2&#123; font-size: 30px; text-shadow:2px 2px 10px red; &#125; .atguigu3&#123; border-radius: 20px; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 绑定样式： 1. class样式 写法:class=&quot;xxx&quot; xxx可以是字符串、对象、数组。 字符串写法适用于：类名不确定，要动态获取。 对象写法适用于：要绑定多个样式，个数不确定，名字也不确定。 数组写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用。 2. style样式 :style=&quot;&#123;fontSize: xxx&#125;&quot;其中xxx是动态值。 :style=&quot;[a,b]&quot;其中a、b是样式对象。 --&gt; &lt;!-- 准备好一个容器--&gt; &lt;div id=&quot;root&quot;&gt; &lt;!-- 绑定class样式--字符串写法，适用于：样式的类名不确定，需要动态指定 --&gt; &lt;div class=&quot;basic&quot; :class=&quot;mood&quot; @click=&quot;changeMood&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;br/&gt;&lt;br/&gt; &lt;!-- 绑定class样式--数组写法，适用于：要绑定的样式个数不确定、名字也不确定 --&gt; &lt;div class=&quot;basic&quot; :class=&quot;classArr&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;br/&gt;&lt;br/&gt; &lt;!-- 绑定class样式--对象写法，适用于：要绑定的样式个数确定、名字也确定，但要动态决定用不用 --&gt; &lt;div class=&quot;basic&quot; :class=&quot;classObj&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;br/&gt;&lt;br/&gt; &lt;!-- 绑定style样式--对象写法 --&gt; &lt;div class=&quot;basic&quot; :style=&quot;styleObj&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;br/&gt;&lt;br/&gt; &lt;!-- 绑定style样式--数组写法 --&gt; &lt;div class=&quot;basic&quot; :style=&quot;styleArr&quot;&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; Vue.config.productionTip = false const vm = new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; name:&#x27;尚硅谷&#x27;, mood:&#x27;normal&#x27;, classArr:[&#x27;atguigu1&#x27;,&#x27;atguigu2&#x27;,&#x27;atguigu3&#x27;], classObj:&#123; atguigu1:false, atguigu2:false, &#125;, styleObj:&#123; fontSize: &#x27;40px&#x27;, color:&#x27;red&#x27;, &#125;, styleObj2:&#123; backgroundColor:&#x27;orange&#x27; &#125;, styleArr:[ &#123; fontSize: &#x27;40px&#x27;, color:&#x27;blue&#x27;, &#125;, &#123; backgroundColor:&#x27;gray&#x27; &#125; ] &#125;, methods: &#123; changeMood()&#123; const arr = [&#x27;happy&#x27;,&#x27;sad&#x27;,&#x27;normal&#x27;] const index = Math.floor(Math.random()*3) this.mood = arr[index] &#125; &#125;, &#125;) &lt;/script&gt; &lt;/html&gt; 1.10 条件渲染 v-if 写法： v-if=&quot;表达式&quot; v-else-if=&quot;表达式&quot; v-else=&quot;表达式&quot; 使用场景：切换频率较低的场景 特点：不展示的DOM元素直接被移除 注意事项 v-if可以和v-else-if、v-else一起使用，但要求结构不能被“打断” v-show 写法：v-show=&quot;表达式&quot; 使用场景：切换频率较高的场景 特点：不展示的DOM元素未被移除，仅仅使用样式隐藏掉 注意事项 使用v-if的时候，元素可能无法获取到，而使用v-show一定可以获取到 代码案例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;条件渲染&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 条件渲染： 1.v-if 写法： (1).v-if=&quot;表达式&quot; (2).v-else-if=&quot;表达式&quot; (3).v-else=&quot;表达式&quot; 适用于：切换频率较低的场景。 特点：不展示的DOM元素直接被移除。 注意：v-if可以和:v-else-if、v-else一起使用，但要求结构不能被“打断”。 2.v-show 写法：v-show=&quot;表达式&quot; 适用于：切换频率较高的场景。 特点：不展示的DOM元素未被移除，仅仅是使用样式隐藏掉 3.备注：使用v-if的时，元素可能无法获取到，而使用v-show一定可以获取到。 --&gt; &lt;!-- 准备好一个容器--&gt; &lt;div id=&quot;root&quot;&gt; &lt;h2&gt;当前的n值是:&#123;&#123;n&#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;n++&quot;&gt;点我n+1&lt;/button&gt; &lt;!-- 使用v-show做条件渲染 --&gt; &lt;!-- &lt;h2 v-show=&quot;false&quot;&gt;欢迎来到&#123;&#123;name&#125;&#125;&lt;/h2&gt; --&gt; &lt;!-- &lt;h2 v-show=&quot;1 === 1&quot;&gt;欢迎来到&#123;&#123;name&#125;&#125;&lt;/h2&gt; --&gt; &lt;!-- 使用v-if做条件渲染 --&gt; &lt;!-- &lt;h2 v-if=&quot;false&quot;&gt;欢迎来到&#123;&#123;name&#125;&#125;&lt;/h2&gt; --&gt; &lt;!-- &lt;h2 v-if=&quot;1 === 1&quot;&gt;欢迎来到&#123;&#123;name&#125;&#125;&lt;/h2&gt; --&gt; &lt;!-- v-else和v-else-if --&gt; &lt;!-- &lt;div v-if=&quot;n === 1&quot;&gt;Angular&lt;/div&gt; &lt;div v-else-if=&quot;n === 2&quot;&gt;React&lt;/div&gt; &lt;div v-else-if=&quot;n === 3&quot;&gt;Vue&lt;/div&gt; &lt;div v-else&gt;哈哈&lt;/div&gt; --&gt; &lt;!-- v-if与template的配合使用 --&gt; &lt;template v-if=&quot;n === 1&quot;&gt; &lt;h2&gt;你好&lt;/h2&gt; &lt;h2&gt;hhu&lt;/h2&gt; &lt;h2&gt;江苏&lt;/h2&gt; &lt;/template&gt; &lt;/div&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; Vue.config.productionTip = false const vm = new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; name:&#x27;hhu&#x27;, n:0 &#125; &#125;) &lt;/script&gt;&lt;/html&gt; 列表渲染基本列表 v-for指令 用于展示列表数据 语法：v-for=&quot;(item,index) in xxx&quot; :key=&quot;yyy&quot; 可遍历：数组、对象、字符串（少）、指定次数（少） 代码示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;基本列表&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;h2&gt;人员列表（遍历数组）&lt;/h2&gt; &lt;ul&gt; &lt;li v-for=&quot;(person,index) in personList&quot; ::key=&quot;person.id&quot;&gt; &#123;&#123;person.name&#125;&#125; - &#123;&#123;person.age&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;h2&gt;汽车信息（遍历对象）&lt;/h2&gt; &lt;ul&gt; &lt;li v-for=&quot;(value,k) of car&quot; :key=&quot;k&quot;&gt;&#123;&#123;k&#125;&#125; - &#123;&#123;value&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; Vue.config.productionTip = false; new Vue(&#123; el: &quot;#root&quot;, data: &#123; personList: [ &#123; id: &quot;001&quot;, name: &quot;张三&quot;, age: 18 &#125;, &#123; id: &quot;002&quot;, name: &quot;李四&quot;, age: 19 &#125;, &#123; id: &quot;003&quot;, name: &quot;王五&quot;, age: 20 &#125;, ], car: &#123; name: &quot;奥迪A8&quot;, price: &quot;70万&quot;, color: &quot;黑色&quot;, &#125;, &#125;, &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; key的原理key是供vue内部使用的，用于vue标识，若:key改成:a，html会渲染成如下情况： 为什么要用:key？ 虚拟DOM中Key的作用 =&gt; Key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】，随后Vue进行【新虚拟DOM】和【旧虚拟DOM】的差异比较，比较规则如下 旧虚拟DOM中找到与新虚拟DOM相同的Key 若虚拟DOM中内容没变，直接使用之前的真实DOM 若虚拟DOM中内容变了，则生成新的真实DOM，随后替换掉页面中之前的真实DOM 旧虚拟DOM中未找到与新虚拟DOM相同的Key 创建新的真实DOM，随后渲染到页面 用index作为Key可能会引发的问题 若对数据进行“逆序添加、逆序删除等”破坏顺序的操作 =&gt; 会产生没有必要的真实DOM的更新 =&gt; 界面渲染没有问题，但是效率低下 如果结构中还包含输入类DOM =&gt; 会产生错误DOM更新 =&gt; 界面有问题 开发中选择Key 使用每条数据的唯一标识作为Key，比如id、手机号、身份证号等 如果不存在对数据的逆序添加、逆序删除等破坏顺序的操作，仅用于渲染列表展示，使用index作为Key是没有问题的 示意图 之所以为什么输入框内容会错位，因为根据diff算法第一个input标签和原来一样，故不作更改：新生成的input在第四行，’老刘’在第一行，故而错位 列表过滤 案例展示123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;列表过滤&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;h2&gt;人员列表&lt;/h2&gt; &lt;input type=&quot;text&quot; placeholder=&quot;请输入名字&quot; v-model=&quot;keywords&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;(person,index) in filPerson&quot; ::key=&quot;index&quot;&gt; &#123;&#123;person.name&#125;&#125; - &#123;&#123;person.age&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; Vue.config.productionTip = false; new Vue(&#123; el: &quot;#root&quot;, data: &#123; keywords:&#x27;&#x27;, personList: [ &#123;id:&#x27;001&#x27;,name:&#x27;马冬梅&#x27;,age:19,sex:&#x27;女&#x27;&#125;, &#123;id:&#x27;002&#x27;,name:&#x27;周冬雨&#x27;,age:20,sex:&#x27;女&#x27;&#125;, &#123;id:&#x27;003&#x27;,name:&#x27;周杰伦&#x27;,age:21,sex:&#x27;男&#x27;&#125;, &#123;id:&#x27;004&#x27;,name:&#x27;温兆伦&#x27;,age:22,sex:&#x27;男&#x27;&#125; ], // filPerson:[] &#125;, /* watch:&#123; keywords:&#123; immediate: true, handler(val) &#123; this.filPerson = this.personList.filter((person)=&gt;&#123; return person.name.indexOf(val) !== -1 &#125;) &#125; &#125; &#125; */ computed:&#123; filPerson()&#123; return this.personList.filter((person)=&gt;&#123; return person.name.indexOf(this.keywords) !== -1 &#125;) &#125; &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 列表排序 代码案例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;列表排序&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;h2&gt;人员列表&lt;/h2&gt; &lt;input type=&quot;text&quot; placeholder=&quot;请输入名字&quot; v-model=&quot;keywords&quot; /&gt; &lt;button @click=&quot;sortType=1&quot;&gt;降序&lt;/button&gt; &lt;button @click=&quot;sortType=2&quot;&gt;升序&lt;/button&gt; &lt;button @click=&quot;sortType=0&quot;&gt;原序&lt;/button&gt; &lt;ul&gt; &lt;li v-for=&quot;(person,index) in filPerson&quot; ::key=&quot;person.id&quot;&gt; &#123;&#123;person.name&#125;&#125; - &#123;&#123;person.age&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; Vue.config.productionTip = false; new Vue(&#123; el: &quot;#root&quot;, data: &#123; keywords: &quot;&quot;, sortType: 0, //排序类型 0=&gt;原顺序 1=&gt;降序 2=&gt;升序 personList: [ &#123; id: &quot;001&quot;, name: &quot;马冬梅&quot;, age: 39, sex: &quot;女&quot; &#125;, &#123; id: &quot;002&quot;, name: &quot;周冬雨&quot;, age: 24, sex: &quot;女&quot; &#125;, &#123; id: &quot;003&quot;, name: &quot;周杰伦&quot;, age: 19, sex: &quot;男&quot; &#125;, &#123; id: &quot;004&quot;, name: &quot;温兆伦&quot;, age: 22, sex: &quot;男&quot; &#125;, ], &#125;, computed: &#123; filPerson() &#123; const arr = this.personList.filter((person) =&gt; &#123; return person.name.indexOf(this.keywords) !== -1; &#125;); if (this.sortType) &#123; arr.sort((p1, p2) =&gt; &#123; return this.sortType === 1 ? p2.age - p1.age : p1.age - p2.age; &#125;); &#125; return arr &#125;, &#125;, &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; （重点） Vue监视数据的原理 Vue会监视data中所有层次的数据 监视对象中的数据 =&gt; 通过setter实现监视，且要在创建Vue示例时就要传入要监视的数据 对象中后追加的属性，Vue默认不做响应式处理 如需给后添加的属性做响应式 =&gt; 使用API Vue.set(target,propertyName/index,value) vm.$set(target,propertyName/index,value) 监视数组中的数据 =&gt; 通过包裹数组更新元素的方法实现，本质做了两件事 调用Js原生对应的方法对数组进行更新 重新解析模板，进而更新页面 在Vue修改数组中的某个元素的方法 API:push()、pop()、shift()、unshift()、splice()、sort()、reverse() Vue.set() or vm.$set() 注意事项 Vue.set() 和 vm.$set()不能给vm或者vm的根数据对象添加属性 代码案例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;数据监测&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;h1&gt;学生信息&lt;/h1&gt; &lt;button @click=&quot;student.age++&quot;&gt;年龄+1岁&lt;/button&gt; &lt;br/&gt; &lt;button @click=&quot;addSex&quot;&gt;添加性别属性，默认值：男&lt;/button&gt; &lt;br/&gt; &lt;button @click=&quot;student.sex = &#x27;none&#x27;&quot;&gt;修改性别&lt;/button&gt; &lt;br/&gt; &lt;button @click=&quot;addFriend&quot;&gt;在列表首位添加一个朋友&lt;/button&gt; &lt;br/&gt; &lt;button @click=&quot;updateFirstFriendName&quot;&gt;修改第一个朋友的名字为：张三&lt;/button&gt; &lt;br/&gt; &lt;button @click=&quot;addHobby&quot;&gt;添加一个爱好&lt;/button&gt; &lt;br/&gt; &lt;button @click=&quot;updateHobby&quot;&gt;修改第一个爱好为：开车&lt;/button&gt; &lt;br/&gt; &lt;button @click=&quot;removeSmoke&quot;&gt;过滤掉爱好中的抽烟&lt;/button&gt; &lt;br/&gt; &lt;h3&gt;name:&#123;&#123;student.name&#125;&#125;&lt;/h3&gt; &lt;h3&gt;age:&#123;&#123;student.age&#125;&#125;&lt;/h3&gt; &lt;h3 v-if=&quot;student.sex&quot;&gt;sex:&#123;&#123;student.sex&#125;&#125;&lt;/h3&gt; &lt;h3&gt;hobby:&lt;/h3&gt; &lt;ul&gt; &lt;li v-for=&quot;(h,index) in student.hobby&quot; :key=&quot;index&quot;&gt; &#123;&#123;h&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;h3&gt;friends:&lt;/h3&gt; &lt;ul&gt; &lt;li v-for=&quot;(f,index) in student.friends&quot;&gt; &#123;&#123;f.name&#125;&#125;--&#123;&#123;f.age&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; Vue.config.productionTip = false; new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; student:&#123; name:&#x27;tom&#x27;, age:18, hobby:[&#x27;抽烟&#x27;,&#x27;喝酒&#x27;,&#x27;烫头&#x27;], friends:[ &#123;name:&#x27;jerry&#x27;,age:35&#125;, &#123;name:&#x27;tony&#x27;,age:36&#125; ] &#125; &#125;, methods: &#123; addSex()&#123; // Vue.set(this.student,&#x27;sex&#x27;,&#x27;man&#x27;) this.$set(this.student,&#x27;sex&#x27;,&#x27;man&#x27;) &#125;, addFriend()&#123; this.student.friends.unshift(&#123;name:&#x27;jack&#x27;,age:70&#125;) &#125;, updateFirstFriendName()&#123; this.student.friends[0].name = &#x27;张三&#x27; &#125;, addHobby()&#123; this.student.hobby.push(&#x27;study&#x27;) &#125;, updateHobby()&#123; // this.student.hobby.splice(0,1,&#x27;Drive&#x27;) // Vue.set(this.student.hobby,0,&#x27;Drive&#x27;) this.$set(this.student.hobby,0,&#x27;Drive&#x27;) &#125;, removeSmoke()&#123; this.student.hobby = this.student.hobby.filter((h)=&gt;&#123; return h !== &#x27;抽烟&#x27; &#125;) &#125; &#125;, &#125;) &lt;/script&gt;&lt;/html&gt; 收集表单数据 若：&lt;input type=&quot;text&quot;/&gt;，则v-model收集的是value值，用户输入的就是value值 若：&lt;input type=&quot;radio&quot;/&gt;，则v-model收集的是value值，且要给标签配置value值 若：&lt;input type=&quot;checkbox&quot;/&gt; 没有配置input的value属性，那么收集的就是checked（勾选 or 未勾选，是布尔值） 配置input的value属性 v-model的初始值是非数组，那么收集的就是checked（勾选 or 未勾选，是布尔值） v-model的初始值是数组，那么收集的的就是value组成的数组 代码示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;收集表单数据&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;form @submit.prevent=&quot;demo&quot;&gt; 账号：&lt;input type=&quot;text&quot; v-model.trim=&quot;userInfo.userAccount&quot;&gt;&lt;br&gt;&lt;br&gt; 密码：&lt;input type=&quot;password&quot; v-model=&quot;userInfo.userPassword&quot;&gt;&lt;br&gt;&lt;br&gt; 年龄：&lt;input type=&quot;number&quot; v-model.number=&quot;userInfo.age&quot;&gt;&lt;br&gt;&lt;br&gt; 性别： 男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; v-model=&quot;userInfo.sex&quot; value=&quot;male&quot;&gt; 女&lt;input type=&quot;radio&quot; name=&quot;sex&quot; v-model=&quot;userInfo.sex&quot; value=&quot;famale&quot;&gt; &lt;br&gt;&lt;br&gt; 爱好： 学习&lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.hobby&quot; value=&quot;study&quot;&gt; 跑步&lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.hobby&quot; value=&quot;run&quot;&gt; 吃饭&lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.hobby&quot; value=&quot;eat&quot;&gt; &lt;br&gt;&lt;br&gt; 所在城市： &lt;select v-model=&quot;userInfo.city&quot;&gt; &lt;option value=&quot;&quot;&gt;请选择城市&lt;/option&gt; &lt;option value=&quot;beijing&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;jiangsu&quot;&gt;江苏&lt;/option&gt; &lt;option value=&quot;anhui&quot;&gt;安徽&lt;/option&gt; &lt;option value=&quot;zhejiang&quot;&gt;浙江&lt;/option&gt; &lt;/select&gt; &lt;br&gt;&lt;br&gt; 其他信息： &lt;textarea v-model.lazy=&quot;userInfo.other&quot;&gt;&lt;/textarea&gt;&lt;br&gt;&lt;br&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;userInfo.agree&quot;&gt;阅读并接受 &lt;a href=&quot;https:www.github.com/CodingJuzi&quot;&gt;《用户协议》&lt;/a&gt; &lt;br&gt; &lt;button&gt;提交&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; Vue.config.productionTip = false; new Vue(&#123; el: &quot;#root&quot;, data: &#123; userInfo:&#123; userAccount:&#x27;&#x27;, userPassword:&#x27;&#x27;, age:&#x27;&#x27;, sex:&#x27;&#x27;, hobby:[], city:&#x27;jiangsu&#x27;, other:&#x27;&#x27;, agree:&#x27;&#x27; &#125; &#125;, methods: &#123; demo()&#123; console.log(JSON.stringify(this.userInfo)) &#125; &#125;, &#125;); &lt;/script&gt;&lt;/html&gt; 过滤器 定义：对要显示的数据进行特定格式化后再显示 语法： 注册过滤器：Vue.filter(name,callback)或者new Vue&#123;filters:&#123;&#125;&#125; 使用过滤器：&#123;&#123;xxx | 过滤器名&#125;&#125; 或者v-bind:属性=&quot;xxx | 过滤器名&quot; 备注 过滤器也可以接收额外参数、多个过滤器也可以串联 过滤器并未改变原本的数据，而是产生了新的对应的数据 代码案例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;过滤器&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../js/dayjs.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 准备好一个容器--&gt; &lt;div id=&quot;root&quot;&gt; &lt;h2&gt;显示格式化后的时间&lt;/h2&gt; &lt;!-- 计算属性实现 --&gt; &lt;h3&gt;现在是：&#123;&#123;fmtTime&#125;&#125;&lt;/h3&gt; &lt;!-- methods实现 --&gt; &lt;h3&gt;现在是：&#123;&#123;getFmtTime()&#125;&#125;&lt;/h3&gt; &lt;!-- 过滤器实现 --&gt; &lt;h3&gt;现在是：&#123;&#123;time | timeFormater&#125;&#125;&lt;/h3&gt; &lt;!-- 过滤器实现（传参） --&gt; &lt;h3&gt;现在是：&#123;&#123;time | timeFormater(&#x27;YYYY_MM_DD&#x27;) | mySlice&#125;&#125;&lt;/h3&gt; &lt;h3 :x=&quot;msg | mySlice&quot;&gt;hhu&lt;/h3&gt; &lt;/div&gt; &lt;div id=&quot;root2&quot;&gt; &lt;h2&gt;&#123;&#123;msg | mySlice&#125;&#125;&lt;/h2&gt; &lt;/div&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; Vue.config.productionTip = false //全局过滤器 Vue.filter(&#x27;mySlice&#x27;,function(value)&#123; return value.slice(0,4) &#125;) new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; time:1621561377603, //时间戳 msg:&#x27;Hello,hhu&#x27; &#125;, computed: &#123; fmtTime()&#123; return dayjs(this.time).format(&#x27;YYYY年MM月DD日 HH:mm:ss&#x27;) &#125; &#125;, methods: &#123; getFmtTime()&#123; return dayjs(this.time).format(&#x27;YYYY年MM月DD日 HH:mm:ss&#x27;) &#125; &#125;, //局部过滤器 filters:&#123; timeFormater(value,str=&#x27;YYYY年MM月DD日 HH:mm:ss&#x27;)&#123; return dayjs(value).format(str) &#125; &#125; &#125;) new Vue(&#123; el:&#x27;#root2&#x27;, data:&#123; msg:&#x27;hello,atguigu!&#x27; &#125; &#125;) &lt;/script&gt;&lt;/html&gt; 1.14 内置指令 已经学过的指令 v-bind : 单向绑定解析表达式, 可简写为 :xxx v-model : 双向数据绑定 v-for : 遍历数组/对象/字符串 v-on : 绑定事件监听, 可简写为@ v-if : 条件渲染（动态控制节点是否存存在） v-else : 条件渲染（动态控制节点是否存存在） v-show : 条件渲染 (动态控制节点是否展示) 1.14.1 v-text 作用：向其所在的节点中渲染文本内容 与插值语法的区别：v-text会替换掉节点中的内容，&#123;&#123;xx&#125;&#125;不会 1.14.2 v-html 作用：向指定节点中渲染包含html结构的内容 与插值语法的区别 v-html会替换掉节点中所有的内容，&#123;&#123;xx&#125;&#125;不会 v-html可以识别html结构 注意事项 v-html有安全性问题 在网站上动态渲染任意HTML是非常危险的，容易导致XSS攻击 一定要在可信的内容上使用v-html，永远不要使用在用户提交的内容上 1.14.3 v-cloak 没有值 本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性 使用css配合v-cloak可以解决网速慢时页面展示出现&#123;&#123;XXX&#125;&#125;的问题 1.14.4 v-once v-once所在的节点在初次动态渲染后，就被视为静态内容 以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能 1.14.5 v-pre 跳过其所在节点的编译过程 可利用他跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译 1.15 自定义指令 定义语法 局部指令 1234567new Vue(&#123; directives:&#123;指令名：配置对象&#125;&#125;)&lt;!-- 或者 --&gt;new Vue(&#123; directives:&#123;指令名：回调函数&#125;&#125;) 全局指令 123Vue.directive(指令名,配置对象)&lt;!-- 或者 --&gt;Vue.directive(指令名,回调函数) 配置对象中常用的3个回调 bind:指定与元素成功绑定时调用 inserted:指令所在的元素被插入页面时调用 update:指令所在的模板被重新解析时调用 备注 指令定义时不加v-，但是使用时要在v- 指令名如果是多个单词，要使用kabab-case命名方式，不要使用camelCase命名 代码示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;自定义指令&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;h2&gt;当前的n值是：&lt;span v-text=&quot;n&quot;&gt;&lt;/span&gt;&lt;/h2&gt; &lt;h2&gt;放大10倍后的n值是：&lt;span v-big=&quot;n&quot;&gt;&lt;/span&gt;&lt;/h2&gt; &lt;button @click=&quot;n++&quot;&gt;点我n++&lt;/button&gt; &lt;hr&gt; &lt;input type=&quot;text&quot; v-fbind:value=&quot;n&quot;&gt; &lt;/div&gt;&lt;/body&gt; &lt;script&gt; Vue.config.productionTip = false //全局指令 /* Vue.directive(&#x27;fbind&#x27;,&#123; //指令与元素成功绑定时 bind(element,binding)&#123; element.innerText = binding.value; &#125;, //指令所在元素被插入页面时 inserted(element,binding) &#123; element.focus() &#125;, //指令所在的模板被重新解析时 update(element,binding) &#123; element.innerText = binding.value &#125; &#125;) */ /* Vue.directive(&#x27;big&#x27;,function(element,binding)&#123; element.innerText = binding.value * 10 &#125;) */ new Vue(&#123; el:&#x27;#root&#x27;, data:&#123; n:1 &#125;, directives:&#123; //big函数调用时机 /* 1.指令与元素成功绑定时 2.指令所在的模板被重新解析时 */ big(element,binding)&#123; element.innerText = binding.value * 10 &#125;, fbind:&#123; //指令与元素成功绑定时 bind(element,binding)&#123; element.innerText = binding.value; &#125;, //指令所在元素被插入页面时 inserted(element,binding) &#123; element.focus() &#125;, //指令所在的模板被重新解析时 update(element,binding) &#123; element.innerText = binding.value &#125; &#125; &#125; &#125;) &lt;/script&gt;&lt;/html&gt; （重点） 生命周期 别名：生命周期回调函数、生命周期函数、生命周期钩子 =&gt; Vue在关键时刻调用的一些特殊名称的函数 生命周期函数的名称不可更改，但是函数的具体内容是根据需求编写的 生命周期函数中this指向是vm或者组件实例对象 示意图 常用的生命周期钩子 mounted：发送Ajax请求、启动定时器、绑定自定义事件、订阅信息等【初始化操作】 beforeDestroy：清除定时器、解除自定义事件、取消订阅消息等【收尾工作】 关于销毁Vue实例的几点说明 销毁后借助Vue开发者工具看不到任何消息 销毁后自定义事件会失效，但原生DOM事件依然有效 一般不会在beforeDestroy操作数据，因为即便操作数据，也不会再发出更新流程 2 Vue组件化编程2.1 模块与组件、模块化与组件化2.1.1 模块 理解: 向外提供特定功能的 js 程序, 一般就是一个 js 文件 为什么: js 文件很多很复杂 作用: 复用 js, 简化 js 的编写, 提高 js 运行效率 2.1.2 组件 理解: 用来实现局部(特定)功能效果的代码集合(html/css/js/image…..) 为什么: 一个界面的功能很复杂 作用：复用编码、简化项目编码、提高运行效率 2.1.3 模块化当应用中的功能都是多组件的方式来编写的，那这个应用就是一个组件化的应用 2.1.4 组件化当应用中的功能都是多组件的方式来编写的，那这个应用就是一个组件化的应用 2.2 非单文件组件2.2.1 基本使用 Vue中使用组件的三大步骤 定义组件（创建组件） 注册组件 使用组件（写组件标签） 定义组件 使用Vue.extend(options)创建，其中options和new Vue(options)时传入的options几乎一样 区别： 不写el =&gt; 最终所有的组件都要经过一个vm的管理，由vm中的el决定 函数式data =&gt; 避免组件被复用时，数据存在引用关系 备注 使用template可以配置组件结构 注册组件 局部注册：靠new Vue()的时候传入components选项 全局注册：靠Vue.component(&#39;组件名&#39;,组件) 编写组件标签 &lt;组件名&gt;&lt;/组件名&gt; 代码示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;组件的基本使用&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;hello&gt;&lt;/hello&gt; &lt;hr&gt; &lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt; &lt;!-- 编写组件标签 --&gt; &lt;school&gt;&lt;/school&gt; &lt;hr&gt; &lt;student&gt;&lt;/student&gt; &lt;/div&gt; &lt;hr&gt; &lt;div id=&quot;root2&quot;&gt; &lt;hello&gt;&lt;/hello&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; Vue.config.productionTip = false; //① 创建组件 //学校组件 const school = Vue.extend(&#123; template: ` &lt;div class=&quot;demo&quot;&gt; &lt;h2&gt;学校名称：&#123;&#123;schoolName&#125;&#125;&lt;/h2&gt; &lt;h2&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;showName&quot;&gt;点我提示学校名&lt;/button&gt; &lt;/div&gt; `, data() &#123; return &#123; schoolName: &quot;hhu&quot;, address: &quot;江苏&quot;, &#125;; &#125;, methods: &#123; showName()&#123; alert(this.schoolName) &#125; &#125;, &#125;); //学生组件 const student = Vue.extend(&#123; template:` &lt;div&gt; &lt;h2&gt;学生姓名：&#123;&#123;studentName&#125;&#125;&lt;/h2&gt; &lt;h2&gt;学生年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt; &lt;/div&gt; `, data()&#123; return &#123; studentName:&#x27;张三&#x27;, age:18 &#125; &#125; &#125;) //hello组件 const hello = Vue.extend(&#123; template:` &lt;div&gt; &lt;h2&gt;你好啊！&#123;&#123;name&#125;&#125;&lt;/h2&gt; &lt;/div&gt; `, data()&#123; return &#123; name:&#x27;Tom&#x27; &#125; &#125; &#125;) //全局注册 Vue.component(&#x27;hello&#x27;,hello) new Vue(&#123; el: &quot;#root&quot;, data: &#123; msg: &quot;Hello&quot;, &#125;, //② 注册组件(局部注册) components:&#123; school, student &#125; &#125;); new Vue(&#123; el:&#x27;#root2&#x27; &#125;) &lt;/script&gt;&lt;/html&gt; 2.2.2 注意事项 关于组件名: 一个单词组成 第一种写法(首字母小写)：school 第二种写法(首字母大写)：School 多个单词组成： 第一种写法(kebab-case命名)：my-school 第二种写法(CamelCase命名)：MySchool (需要Vue脚手架支持) 备注： 组件名尽可能回避HTML中已有的元素名称，例如：h2、H2都不行。 可以使用name配置项指定组件在开发者工具中呈现的名字 关于组件标签: 第一种写法： 第二种写法： 备注：不用使用脚手架时，会导致后续组件不能渲染。 一个简写方式 const school = Vue.extend(options) =&gt; const school = options 2.2.3 组件的嵌套 代码示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;组件的嵌套&lt;/title&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;hr /&gt; &lt;/body&gt; &lt;script&gt; Vue.config.productionTip = false; //① 创建组件 //学生组件 const student = Vue.extend(&#123; template: ` &lt;div&gt; &lt;h2&gt;学生姓名：&#123;&#123;studentName&#125;&#125;&lt;/h2&gt; &lt;h2&gt;学生年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt; &lt;/div&gt; `, data() &#123; return &#123; studentName: &quot;张三&quot;, age: 18, &#125;; &#125;, &#125;); //学校组件 const school = Vue.extend(&#123; template: ` &lt;div&gt; &lt;h2&gt;学校名称：&#123;&#123;schoolName&#125;&#125;&lt;/h2&gt; &lt;h2&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h2&gt; &lt;student&gt;&lt;/student&gt; &lt;/div&gt; `, data() &#123; return &#123; schoolName: &quot;hhu&quot;, address: &quot;江苏&quot;, &#125;; &#125;, //注册组件（局部） components: &#123; student, &#125;, &#125;); //hello组件 const hello = Vue.extend(&#123; template: ` &lt;div&gt; &lt;h2&gt;Welcome to &#123;&#123;msg&#125;&#125;&lt;/h2&gt; &lt;/div&gt; `, data() &#123; return &#123; msg: &quot;hhu&quot;, &#125;; &#125;, &#125;); //定义App组件 const app = &#123; template: ` &lt;div&gt; &lt;hello&gt;&lt;/hello&gt; &lt;school&gt;&lt;/school&gt; &lt;/div&gt; `, components: &#123; school, hello, &#125;, &#125;; //全局注册 Vue.component(&quot;hello&quot;, hello); new Vue(&#123; template: ` &lt;div&gt; &lt;app&gt;&lt;/app&gt; &lt;/div&gt; `, el: &quot;#root&quot;, //② 注册组件(局部注册) components: &#123; app, &#125;, &#125;); &lt;/script&gt;&lt;/html&gt; 嵌套示意图 2.2.4 VueComponent 组件的本质是一个名为VueComponent的构造函数，不是由程序员定义，是Vue.extend生成的 编写组件标签时，Vue解析时会帮我们创建组件的实例对象，即Vue帮我们执行的：new VueComponent(options) 特别注意：每次调用Vue.extend，返回的都是一个全新的VueComponent 12345678Vue.extend = function (extendOptions) &#123; /*………………*/ var Sub = function VueComponent(options) &#123; this._init(options); &#125;; /*………………*/ return Sub; &#125;; 关于this指向 组件配置中 data函数、methods中的函数、watch中的函数、computed中的函数，它们的this均是【VueComponent实例对象】 new Vue(options)配置中 data函数、methods中的函数、watch中的函数、computed中的函数，它们的this均是【Vue实例对象】 VueComponent的实例对象，以后简称vc（也可称之为：组件实例对象） Vue的实例对象，以后简称vm 2.2.5 一个重要的内置关系 VueComponent.prototype.__proto__ === Vue.prototype 作用 =&gt; 让组件实例对象能够访问到Vue原型上的属性、方法 分析示意图 2.3 单文件组件 xxx.vue文件 =&gt; 内部书写组件 template =&gt; 组件的结构 script =&gt; 组件相关交互的代码 style =&gt; 组件的样式 代码示例 （练习下格式 没有脚手架，不能运行） School.vue 123456789101112131415161718192021222324252627282930313233&lt;template&gt; &lt;!-- 组件的结构 --&gt; &lt;div class=&quot;demo&quot;&gt; &lt;h2&gt;学校名称：&#123;&#123;name&#125;&#125;&lt;/h2&gt; &lt;h2&gt;学校地址：&#123;&#123;address&#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;showName&quot;&gt;点我提示学校名&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; //组件相关交互的代码 export default &#123; name:&#x27;School&#x27;, data()&#123; return &#123; name:&#x27;hhu&#x27;, address:&#x27;江苏&#x27; &#125; &#125;, methods: &#123; showName()&#123; alert(this.name) &#125; &#125;, &#125;&lt;/script&gt;&lt;style&gt; /* 组件的样式 */ .demo&#123; background-color: orange; &#125;&lt;/style&gt; Student.vue 123456789101112131415161718&lt;template&gt; &lt;div&gt; &lt;h2&gt;学生姓名：&#123;&#123;name&#125;&#125;&lt;/h2&gt; &lt;h2&gt;学生年龄：&#123;&#123;age&#125;&#125;&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name:&#x27;Student&#x27;, data()&#123; return &#123; name:&#x27;jack&#x27;, age:18 &#125; &#125;, &#125;&lt;/script&gt; App.vue 12345678910111213141516171819&lt;template&gt; &lt;div&gt; &lt;School&gt;&lt;/School&gt; &lt;Student&gt;&lt;/Student&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; // 引入组件 import School from &#x27;./School&#x27; import Student from &#x27;./Student&#x27;export default &#123; name:&#x27;App&#x27;, components:&#123; School, Student &#125;&#125;&lt;/script&gt; main.js 1234567import App from &#x27;./App.vue&#x27;new Vue(&#123; el:&#x27;#root&#x27;, template:`&lt;App&gt;&lt;/App&gt;`, components:&#123;App&#125;&#125;) index.html 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;练习单文件组件的语法&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt; &lt;/div&gt; &lt;script src=&quot;../js/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./main.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 使用Vue脚手架初始化脚手架说明 Vue脚手架是Vue官方提供的标准化开发工具（开发平台） 最新的版本是4.x 文档地址：https://cli.vuejs.org/zh/ 具体步骤 官方文档：Home | Vue CLI (vuejs.org) 安装==nodejs== 环境 参考文档：https://www.cnblogs.com/netcore5/p/15259499.html （仅第一次执行）：全局安装@vue/cli 123npm install -g @vue/cli# ORyarn global add @vue/cli 切换到要创建项目的目录，执行命令 123vue create my-project# ORvue ui 示意图 备注 创建项目过程如果报错，使用管理员权限打开cmd 运行过程出现名称错误 解决方案一： ctrl + p =&gt; vue.config.js =&gt; 添加配置 lintOnSave:false Vue脚手架隐藏了所有webpack相关的配置，若想查看具体的webpack配置，执行 1vue inspect &gt; output.js 3.1.3 脚手架文件结构12345678910111213141516├── node_modules ├── public│ ├── favicon.ico: 页签图标│ └── index.html: 主页面├── src│ ├── assets: 存放静态资源│ │ └── logo.png│ │── component: 存放组件│ │ └── HelloWorld.vue│ │── App.vue: 汇总所有组件│ │── main.js: 入口文件├── .gitignore: git版本管制忽略的配置├── babel.config.js: babel的配置文件├── package.json: 应用包配置文件 ├── README.md: 应用描述文件├── package-lock.json：包版本控制文件 3.1.4 render()函数特殊的函数 关于不同版本的Vue vue.js与vue.runtime.xxx.js的区别： vue.js是完整版的Vue，包含：核心功能+模板解析器 vue.runtime.xxx.js是运行版的Vue，只包含：核心功能；没有模板解析器 因为vue.runtime.xxx.js没有模板解析器，所以不能使用template配置项，需要使用 ​ render函数接收到的createElement函数去指定具体内容 3.1.5 脚手架默认配置 官方文档：配置参考 | Vue CLI (vuejs.org) 查看Vue脚手架默认配置 1vue inspect &gt; output.js ref 和 propsref属性 作用：给元素或者子组件注册引用信息（id的替代） 应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象 使用方式 标识：&lt;h1 ref=&quot;xxx&quot;&gt;...&lt;/h1&gt;或者&lt;School ref=&quot;xxx&gt;&gt;&lt;/School&gt; 获取：this.$refs.xxx 这是父组件得到子组件数据的一种重要方式 props配置项 作用：让组件接收外部传入的数据 传递数据：&lt;Demo name=&quot;XXX&quot;/&gt; 接收数据： 方式一（只接收）：props:[&#39;name&#39;] 方式二（限制类型）：props:&#123;name:String&#125; 方式三（限制类型、限制必要性、指定默认值）： 1234567props:&#123; name:&#123; type:String, //类型 required:true, //必要性 default:&#x27;老王&#x27; //默认值 &#125;&#125; 备注：props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据props限制类型可以应用在登录页的输入合法检测上 3.3 mixin（混入） 作用：可以把多个组件共用的配置提取成一个混入对象 使用方式：需要导出和引入 定义混合 12345&#123; data()&#123;...&#125;, methods:&#123;...&#125; ...&#125; 使用混入 全局混入：Vue.mixin(XXX) 局部混入：mixins:[&#39;XXX&#39;] 插件 作用：增强Vue 本质：包含install() 方法的一个对象，install的第一个参数是Vue原型对象，第二个以后的参数是插件使用者传递的数据 定义插件 1234567891011121314对象.install = function(Vue,options) &#123; // 1.添加全局过滤器 Vue.filter(...) // 2.添加全局指令 Vue.directive(...) // 3.配置全局混入 Vue.mixin(....) // 4.添加实例方法 Vue.prototype.$myMethod = function()&#123;...&#125; Vue.prototype.$myProperty = xxx&#125; 使用插件：Vue.use(..) scoped样式 作用：让样式在局部生效，防止冲突 写法：&lt;style scoped&gt; 总结TODOList案例 组件化编码流程： 拆分静态组件：组件要按照功能点拆分，命名不要与html元素冲突。 实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用： 一个组件在用：放在组件自身即可 一些组件在用：放在他们共同的父组件上（状态提升） 实现交互：从绑定事件开始 props适用于： 父组件 ==&gt; 子组件 通信 子组件 ==&gt; 父组件 通信（要求父先给子一个函数） 使用v-model时要切记：v-model绑定的值不能是props传过来的值，因为props是不可以修改的！ props传过来的若是对象类型的值，修改对象中的属性时Vue不会报错，但不推荐这样做。 webStorage 存储内容大小一般支持5MB左右（依照浏览器） 浏览器端通过Window.sessionStorage和window.localStorage属性来实现本地存储机制 相关API xxxStorage.setItem(&#39;key&#39;,&#39;value&#39;) =&gt; 该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值 xxxStorage.getItem(&#39;key&#39;) =&gt; 该方法接受一个键名作为参数，返回键名对应的值 xxxStorage.removeItem(&#39;key&#39;) =&gt; 该方法接受一个键名作为参数，并把该键名从存储中删除 xxxStorage.clear() =&gt; 该方法会清空存储中的所有数据 备注 SessionStorage存储的内容会随着浏览器窗口关闭而消失 LocalStorage的存储的内容需要手动清除才会消失 xxxStorage.getItem(&#39;key&#39;)如果key对应的Value获取不到，则此方法的返回值为null Json.parse(null)的结果依然是null 组件的自定义事件 一种组件间的通信方式，适用于: 子组件===&gt;父组件 使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（事件的回调在A中） 绑定自定义事件 方式一：在父组件中：&lt;Demo @mystyle=&quot;test&quot;/&gt; 或者 &lt;Demo v-on:mystyle=&quot;test&quot;/&gt; 方式二：在父组件中： 12345&lt;Demo ref=&quot;demo&quot;/&gt;.......mounted()&#123; this.$refs.xxx.$on(&#x27;mystyle&#x27;,this.test)&#125; ​若想让自定义事件只触发一次，可以使用once修饰符或者$once方法 触发自定义事件：this.$emit(&#39;mystyle&#39;,数据) 解绑自定义事件：this.$off(&#39;mystyle&#39;) 组件上也可以绑定原生DOM事件，需要使用native修饰符 注意：通过this.$refs.xxx.$on(&#39;mystyle&#39;,回调)绑定自定义事件时，回调要么配置在methods中，要么用箭头函数，否则this指向会有问题 全局事件总线(GlobalEventBus) 一种组件间通信的方式，适用于任意组件间的通信 安装全局事件总线 1234567new Vue(&#123; ...... beforeCreate()&#123; Vue.prototype.$bus = this // 安装全局事件总线，$bus就是当前应用的vm &#125;, .....&#125;) 使用事件总线： 接收数据：A组件想要接收数据，则在A组件中给$bus绑定自定义事件，事件的回调留在A组件自身 1234567methods:&#123; demo(data) &#123;.......&#125;, ....... mounted()&#123; this.$bus.$on(&#x27;xxx&#x27;,this.demo) &#125;&#125; 提供数据：this.$bus.$emit(&#39;xxx&#39;,数据) 注意事项 最好在beforeDestroy钩子中，用$off去解绑当前组件所用到的事件 消息订阅与发布（pubsub) 一种组件间通信的方式，适用于任意组件间的通信 使用步骤 安装pubsub:npm i pubsub-js 引入： import pubsub from &#39;pubsub-js&#39; 接收数据：A组件想要接收数据，则在A组件中订阅消息，订阅的回调留在A中 1234567methods:&#123; demo(data) &#123;......&#125;&#125;......mounted()&#123; this.pid = pubsub.subscribe(&#x27;xxx&#x27;,this.demo)&#125; 提供数据：pubsub.publish(&#39;xxx&#39;,数据) 注意事项 最好在beforeDestroy钩子中，用pubsub.unsubscribe(pid)去取消订阅 nextTick 语法：this.$nextTick(回调函数) 作用：在下一次DOM更新结束后执行其制定的回调 使用时机：当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行 Vue封装的过渡和动画 作用：在插入、更新或者移除DOM元素时，在合适的时候给元素添加样式类名 图示： 写法： 准备好样式： 元素进入的样式 v-enter:进入的起点 v-enter-active:进入过程中 v-enter-to:进入的终点 元素离开的样式 v-leave:离开的起点 v-leave-active:离开过程中 v-leave-to:离开的终点 使用&lt;transition&gt;包裹要过渡的元素，并配置name属性 123&lt;transition name=&quot;hello&quot;&gt; &lt;h1 v-show=&quot;isShow&quot;&gt;你好啊！&lt;/h1&gt;&lt;/transition&gt; 备注：若有多个元素需要过渡，则需要使用:&lt;transition-group&gt;，且每个元素都要指定key值 Vue中的AjaxVue脚手架配置代理 =&gt; 解决跨域问题方式一​ 在vue.config.js中添加如下配置 123devServer:&#123; proxy:&quot;http://localhost:5000&quot;&#125; 说明： 优点：配置简单，请求资源时直接发送给前端即可 缺点：不能配置多个代理，不能灵活的控制请求是否走代理 工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器（优先匹配服务器） 方式二​ 编写vue.config.js配置具体代理规则 123456789101112131415161718192021module.exports = &#123; devServer: &#123; proxy: &#123; &#x27;/api1&#x27;: &#123;// 匹配所有以 &#x27;/api1&#x27;开头的请求路径 target: &#x27;http://localhost:port&#x27;,// 代理目标的基础路径 changeOrigin: true, pathRewrite: &#123;&#x27;^/api1&#x27;: &#x27;&#x27;&#125; &#125;, &#x27;/api2&#x27;: &#123;// 匹配所有以 &#x27;/api2&#x27;开头的请求路径 target: &#x27;http://localhost:port&#x27;,// 代理目标的基础路径 changeOrigin: true, pathRewrite: &#123;&#x27;^/api2&#x27;: &#x27;&#x27;&#125; &#125; &#125; &#125;&#125;/* changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000 changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:8080 changeOrigin默认值为true*/ 说明： 优点：可以配置多个代理，且可以灵活的控制请求是否走代理 缺点：配置略微繁琐，请求资源时必须加前缀 slot插槽 作用：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于父组件 ===&gt; 子组件 分类：默认插槽、具名插槽、作用域插槽 使用方式： 默认插槽： 1234567891011&lt;!-- 父组件中 --&gt; &lt;Category&gt; &lt;div&gt;html结构1&lt;/div&gt; &lt;/Category&gt;&lt;!-- 子组件中 --&gt; &lt;template&gt; &lt;div&gt; &lt;!-- 定义插槽 --&gt; &lt;slot&gt;插槽默认内容...&lt;/slot&gt; &lt;/div&gt; &lt;/template&gt; 具名插槽 123456789101112131415161718&lt;!-- 父组件中 --&gt; &lt;Category&gt; &lt;template slot=&quot;center&quot;&gt; &lt;div&gt;html结构1&lt;/div&gt; &lt;/template&gt; &lt;template v-slot:footer&gt; &lt;div&gt;html结构2&lt;/div&gt; &lt;/template&gt; &lt;/Category&gt;&lt;!-- 子组件中 --&gt; &lt;template&gt; &lt;div&gt; &lt;!-- 定义插槽 --&gt; &lt;slot name=&quot;center&quot;&gt;插槽默认内容...&lt;/slot&gt; &lt;slot name=&quot;footer&quot;&gt;插槽默认内容...&lt;/slot&gt; &lt;/div&gt; &lt;/template&gt; 作用域插槽 理解：数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定(game数据在Category组件中，但使用数据所遍历出来的结构有App组件决定) 具体编码 1234567891011121314151617181920212223242526272829303132333435363738&lt;!-- 父组件中 --&gt;&lt;div id=&#x27;father&#x27;&gt; &lt;Category&gt; &lt;template scope=&quot;scopeData&quot;&gt; &lt;!-- 生成的是ul列表 --&gt; &lt;ul&gt; &lt;li v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/template&gt; &lt;/Category&gt; &lt;Category&gt; &lt;template slot-scope=&quot;scopeData&quot;&gt; &lt;!-- 生成的是h4标题 --&gt; &lt;h4 v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/h4&gt; &lt;/template&gt; &lt;/Category&gt;&lt;/div&gt; &lt;!-- 子组件中 --&gt; &lt;template&gt; &lt;div&gt; &lt;slot :games=&quot;games&quot;&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default &#123; name:&#x27;Category&#x27;, props:[&#x27;title&#x27;], //数据在子组件自身 data() &#123; return &#123; games:[&#x27;红色警戒&#x27;,&#x27;穿越火线&#x27;,&#x27;劲舞团&#x27;,&#x27;超级玛丽&#x27;] &#125; &#125;, &#125; &lt;/script&gt; VuexVuex理解 是什么？专门在 Vue 中实现集中式状态（数据）管理的一个 Vue 插件，对 vue 应 用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方 式，且适用于任意组件间通信 工作原理图 搭建Vuex环境 安装Vuex Vue2 =&gt; Vuex3 版本 1npm i vuex@3 创建文件：src/store/index.js 12345678910111213141516171819// 引入Vue核心import Vue from &#x27;Vue&#x27;// 引入Vueximport Vuex from &#x27;vuex&#x27;// 应用Vuex插件Vue.use(Vuex)// 准备actions对象 =&gt; 响应组件中用户的动作const actions = &#123;&#125;// 准备mutations对象 =&gt; 修改state中的数据const mutations = &#123;&#125;// 准备state对象 =&gt; 保存具体的数据const state = &#123;&#125;// 创建并暴露storeexport default new Vuex.Store(&#123; actions, mutations, state&#125;) 在main.js中创建vm时传入store配置项 123456789.......// 引入storeimport store from &#x27;./store&#x27;.......// 创建vmnew Vue(&#123; render: h =&gt; h(App), store&#125;).$mount(&#x27;#app&#x27;) 5.3 基本使用 初始化数据、配置actions、配置mutations、操作文件store.js 12345678910111213141516171819202122232425262728293031323334//引入Vue核心库import Vue from &#x27;vue&#x27;//引入Vueximport Vuex from &#x27;vuex&#x27;//引用VuexVue.use(Vuex)const actions = &#123; //响应组件中加的动作 jia(context,value)&#123; // console.log(&#x27;actions中的jia被调用了&#x27;,miniStore,value) context.commit(&#x27;JIA&#x27;,value) &#125;,&#125;const mutations = &#123; //执行加 JIA(state,value)&#123; // console.log(&#x27;mutations中的JIA被调用了&#x27;,state,value) state.sum += value &#125;&#125;//初始化数据const state = &#123; sum:0&#125;//创建并暴露storeexport default new Vuex.Store(&#123; actions, mutations, state,&#125;) 组件中读取vuex中的数据：$store.state.xxx 组件中修改vuex中的数据：$store.dispatch(&#39;actions中的方法名&#39;,数据)或者$store.commit(&#39;mutations中的方法名&#39;,数据) 备注：若没有网络请求或者其他业务逻辑，组件中也可以越过actions，即不写dispatch，直接编写commit getters的使用 概念：当state中的数据需要经过加工后再使用时，可以使用getters加工 在store.js中追加getters配置 12345678910111213......const getters = &#123; bigSum(state)&#123; return state.sum * 10 &#125;&#125;//创建并暴露storeexport default new Vuex.Store(&#123; ...... getters&#125;) 组件中读取数据：$store.getters.bigSum map方法使用 mapState方法 =&gt; 用于帮助我们映射state中的数据为计算属性 1234567computed: &#123; //借助mapState生成计算属性：sum、school、subject（对象写法） ...mapState(&#123;sum:&#x27;sum&#x27;,school:&#x27;school&#x27;,subject:&#x27;subject&#x27;&#125;), //借助mapState生成计算属性：sum、school、subject（数组写法） ...mapState([&#x27;sum&#x27;,&#x27;school&#x27;,&#x27;subject&#x27;]),&#125;, mapGetters方法 =&gt; 用于帮助我们映射getters中的数据为计算属性 1234567computed: &#123; //借助mapGetters生成计算属性：bigSum（对象写法） ...mapGetters(&#123;bigSum:&#x27;bigSum&#x27;&#125;), //借助mapGetters生成计算属性：bigSum（数组写法） ...mapGetters([&#x27;bigSum&#x27;])&#125;, mapActions方法 =&gt; 用于帮助我们生成与actions对话的方法，即包含$state.dispatch(xxx)的函数 1234567methods:&#123; //靠mapActions生成：incrementOdd、incrementWait（对象形式） ...mapActions(&#123;incrementOdd:&#x27;jiaOdd&#x27;,incrementWait:&#x27;jiaWait&#x27;&#125;) //靠mapActions生成：incrementOdd、incrementWait（数组形式） ...mapActions([&#x27;jiaOdd&#x27;,&#x27;jiaWait&#x27;])&#125; mapMutations方法 =&gt; 用于帮助我们生成与mutations对话的方法，即包含$state.commit(xxx)的函数 1234567methods:&#123; //靠mapActions生成：increment、decrement（对象形式） ...mapMutations(&#123;increment:&#x27;JIA&#x27;,decrement:&#x27;JIAN&#x27;&#125;), //靠mapMutations生成：JIA、JIAN（对象形式） ...mapMutations([&#x27;JIA&#x27;,&#x27;JIAN&#x27;]),&#125; 备注：mapActions 与 mapMutations 使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象 模块化 + 命名空间 目的：让代码更好维护，让多种数据分类更加明确 修改store.js 12345678910111213141516171819202122232425const countAbout = &#123; namespaced:true,//开启命名空间 state:&#123;x:1&#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; bigSum(state)&#123; return state.sum * 10 &#125; &#125;&#125;const personAbout = &#123; namespaced:true,//开启命名空间 state:&#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123; modules: &#123; countAbout, personAbout &#125;&#125;) 开启命名空间后，组件中读取state数据 1234//方式一：自己直接读取this.$store.state.personAbout.list//方式二：借助mapState读取：...mapState(&#x27;countAbout&#x27;,[&#x27;sum&#x27;,&#x27;school&#x27;,&#x27;subject&#x27;]), 开启命名空间后，组件中读取getters数据 1234//方式一：自己直接读取this.$store.getters[&#x27;personAbout/firstPersonName&#x27;]//方式二：借助mapGetters读取：...mapGetters(&#x27;countAbout&#x27;,[&#x27;bigSum&#x27;]) 开启命名空间后，组件中调用dispatch 1234//方式一：自己直接dispatchthis.$store.dispatch(&#x27;personAbout/addPersonWang&#x27;,person)//方式二：借助mapActions：...mapActions(&#x27;countAbout&#x27;,&#123;incrementOdd:&#x27;jiaOdd&#x27;,incrementWait:&#x27;jiaWait&#x27;&#125;) 开启命名空间后，组件中调用commit 1234//方式一：自己直接committhis.$store.commit(&#x27;personAbout/ADD_PERSON&#x27;,person)//方式二：借助mapMutations：...mapMutations(&#x27;countAbout&#x27;,&#123;increment:&#x27;JIA&#x27;,decrement:&#x27;JIAN&#x27;&#125;), 6 vue-router 理解：一个路由(route)就是一组映射关系(key - value)，多个路由需要路由器(router)进行管理 前端路由：key是路径，value是组件 6.1 基本使用 安装vue-router（Vue2 =&gt; vue-router3) 1npm i vue-router@3 应用插件：Vue.user(VueRouter) 编写router配置项:src/router/index.js 1234567891011121314151617181920// 专门用于创建整个应用的路由器import VueRouter from &quot;vue-router&quot;;// 引入组件import About from &#x27;@/components/About&#x27;import Home from &#x27;@/components/Home&#x27;// 创建并暴露路由export default new VueRouter(&#123; routes:[ &#123; path:&#x27;/about&#x27;, component:About &#125;, &#123; path:&#x27;/home&#x27;, component:Home &#125; ]&#125;) 实现切换(active-class可以配置高亮样式) 1&lt;router-link active-class=&quot;active&quot; to=&quot;/about&quot;&gt;About&lt;/router-link&gt; 指定展示位置 1&lt;router-view&gt;&lt;/router-view&gt; 6.2 注意事项 路由组件通常存放在pages文件夹，一般组件通常存放在components文件夹 通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载 每个组件都有自己的$route属性，里面存储着自己的路由信息 整个应用只有一个router，可以通过组件的$router属性获取到 6.3 多级路由（嵌套路由） 配置路由规则，使用children配置项 1234567891011121314151617181920routes:[ &#123; path:&#x27;/about&#x27;, component:About &#125;, &#123; path:&#x27;/home&#x27;, component:Home, children:[ &#123; path:&#x27;news&#x27;, component:News &#125;, &#123; path:&#x27;message&#x27;, component:Message &#125; ] &#125; ] 跳转（完整路径） 1&lt;router-link class=&quot;list-group-item&quot; active-class=&quot;active&quot; to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt; 路由的query参数 传递参数 12345678910111213&lt;!-- 跳转并携带query参数，to的字符串写法 --&gt;&lt;router-link :to=&quot;/home/message/detail?id=666&amp;title=你好&quot;&gt;跳转&lt;/router-link&gt; &lt;!-- 跳转并携带query参数，to的对象写法 --&gt;&lt;router-link :to=&quot;&#123; path:&#x27;/home/message/detail&#x27;, query:&#123; id:666, title:&#x27;你好&#x27; &#125; &#125;&quot;&gt;跳转&lt;/router-link&gt; 接收参数 12$route.query.id$route.query.title 命名路由 作用：可以简化路由的跳转 使用方法： 给路由命名 1234567891011121314151617&#123; path:&#x27;/demo&#x27;, component:Demo, children:[ &#123; path:&#x27;test&#x27;, component:Test, children:[ &#123; name:&#x27;hello&#x27; //给路由命名 path:&#x27;welcome&#x27;, component:Hello, &#125; ] &#125; ]&#125; 简化跳转 12345678910111213141516&lt;!--简化前，需要写完整的路径 --&gt;&lt;router-link to=&quot;/demo/test/welcome&quot;&gt;跳转&lt;/router-link&gt;&lt;!--简化后，直接通过名字跳转 --&gt;&lt;router-link :to=&quot;&#123;name:&#x27;hello&#x27;&#125;&quot;&gt;跳转&lt;/router-link&gt;&lt;!--简化写法配合传递参数 --&gt;&lt;router-link :to=&quot;&#123; name:&#x27;hello&#x27;, query:&#123; id:666, title:&#x27;你好&#x27; &#125; &#125;&quot;&gt;跳转&lt;/router-link&gt; 路由的params参数 配置路由，声明接收params参数 1234567891011121314151617181920&#123; path:&#x27;/home&#x27;, component:Home, children:[ &#123; path:&#x27;news&#x27;, component:News &#125;, &#123; component:Message, children:[ &#123; name:&#x27;xiangqing&#x27;, path:&#x27;detail/:id/:title&#x27;, //使用占位符声明接收params参数 component:Detail &#125; ] &#125; ]&#125; 传递参数 12345678910111213&lt;!-- 跳转并携带params参数，to的字符串写法 --&gt;&lt;router-link :to=&quot;/home/message/detail/666/你好&quot;&gt;跳转&lt;/router-link&gt; &lt;!-- 跳转并携带params参数，to的对象写法 --&gt;&lt;router-link :to=&quot;&#123; name:&#x27;xiangqing&#x27;, params:&#123; id:666, title:&#x27;你好&#x27; &#125; &#125;&quot;&gt;跳转&lt;/router-link&gt; 特别注意：路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置！ 接收参数 12$route.params.id$route.params.title 路由的props参数 作用：让路由组件更方便的接收参数 12345678910111213141516171819&#123; name:&#x27;xiangqing&#x27;, path:&#x27;detail/:id&#x27;, component:Detail, //第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件 // props:&#123;a:900&#125; //第二种写法：props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件 // props:true //第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件 props(route)&#123; return &#123; id:route.query.id, title:route.query.title &#125; &#125;&#125; &lt;router-link&gt;的replace属性 作用：控制路由跳转时操作浏览器历史记录的模式 浏览器的历史记录的写入模式：push和replace，push是追加历史记录，replace是替换当前记录，路由跳转时候默认是push 开启replace模式：&lt;router-link replace .......&gt;News&lt;/router-link&gt; 编程式路由导航 作用：不借助&lt;router-link&gt;实现路由跳转，让路由跳转更加灵活 代码示例 12345678910111213141516171819//$router的两个APIthis.$router.push(&#123; name:&#x27;xiangqing&#x27;, params:&#123; id:xxx, title:xxx &#125;&#125;)this.$router.replace(&#123; name:&#x27;xiangqing&#x27;, params:&#123; id:xxx, title:xxx &#125;&#125;)this.$router.forward() //前进this.$router.back() //后退this.$router.go() //可前进也可后退(传入正数前进，负数后退) 缓存路由组件 组件：让不展示的路由组件保持挂载，不被销毁(在展示组件的地方挂载) 代码示例 1234567&lt;keep-alive include=&quot;News&quot;&gt; &lt;!-- 缓存多个 &lt;keep-alive :include=&quot;[&#x27;News&#x27;,&#x27;Message&#x27;]&quot;&gt;--&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt; include =&gt; 组件名 两个新的生命周期钩子 作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态 具体名字： activated =&gt; 路由组件被激活时触发 deactivated =&gt; 路由组件失活时触发 路由守卫 作用：对路由进行权限控制 分类 全局守卫 独享守卫 组件内守卫 代码示例 全局守卫 123456789101112131415161718192021222324//全局前置守卫：初始化时执行、每次路由切换前执行router.beforeEach((to,from,next)=&gt;&#123; console.log(&#x27;beforeEach&#x27;,to,from) if(to.meta.isAuth)&#123; //判断当前路由是否需要进行权限控制 if(localStorage.getItem(&#x27;school&#x27;) === &#x27;atguigu&#x27;)&#123; //权限控制的具体规则 next() //放行 &#125;else&#123; alert(&#x27;暂无权限查看&#x27;) // next(&#123;name:&#x27;guanyu&#x27;&#125;) &#125; &#125;else&#123; next() //放行 &#125;&#125;)//全局后置守卫：初始化时执行、每次路由切换后执行router.afterEach((to,from)=&gt;&#123; console.log(&#x27;afterEach&#x27;,to,from) if(to.meta.title)&#123; document.title = to.meta.title //修改网页的title &#125;else&#123; document.title = &#x27;vue_test&#x27; &#125;&#125;) 独享守卫 12345678910111213beforeEnter(to,from,next)&#123; console.log(&#x27;beforeEnter&#x27;,to,from) if(to.meta.isAuth)&#123; //判断当前路由是否需要进行权限控制 if(localStorage.getItem(&#x27;school&#x27;) === &#x27;atguigu&#x27;)&#123; next() &#125;else&#123; alert(&#x27;暂无权限查看&#x27;) // next(&#123;name:&#x27;guanyu&#x27;&#125;) &#125; &#125;else&#123; next() &#125;&#125; 组件内守卫 123456//进入守卫：通过路由规则，进入该组件时被调用beforeRouteEnter (to, from, next) &#123;&#125;,//离开守卫：通过路由规则，离开该组件时被调用beforeRouteLeave (to, from, next) &#123;&#125; 路由器的两种工作方式 对于一个url，hash =&gt; #及其之后的内容 hash值不会包含在HTTP请求中，即hash值不会带给服务器 hash模式： 地址中永远带着#号，不美观 。 若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法。 兼容性较好。 history模式： 地址干净，美观 。 兼容性和hash模式相比略差。 应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。 开启方式：创建路由器时配置 12mode:&#x27;history&#x27;mode:&#x27;hash&#x27;","categories":[{"name":"日常学习","slug":"日常学习","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}]},{"title":"prototype原型","slug":"prototype原型","date":"2022-12-26T05:30:41.000Z","updated":"2023-01-31T13:01:43.086Z","comments":true,"path":"posts/56ec4144.html","link":"","permalink":"http://example.com/posts/56ec4144.html","excerpt":"","text":"原型（prototype） 函数的prototye属性 每个函数都有一个prototype属性，它默认指向一个object空对象（原型对象） 原型对象中有一个属性constructor，它指向函数对象 1console.log(Data.prototype.construct===Data)//true 给原型对象添加属性（一般是方法） 作用：函数的所有实例对象自动拥有原型中的属性（方法）","categories":[{"name":"日常学习","slug":"日常学习","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"}]}],"categories":[{"name":"刷题","slug":"刷题","permalink":"http://example.com/categories/%E5%88%B7%E9%A2%98/"},{"name":"作品练手","slug":"作品练手","permalink":"http://example.com/categories/%E4%BD%9C%E5%93%81%E7%BB%83%E6%89%8B/"},{"name":"日常学习","slug":"日常学习","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://example.com/tags/leetcode/"},{"name":"javascript","slug":"javascript","permalink":"http://example.com/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}]}